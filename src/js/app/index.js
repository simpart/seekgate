!function(t){var r={};function o(e){if(r[e])return r[e].exports;var n=r[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,o),n.l=!0,n.exports}o.m=t,o.c=r,o.d=function(e,n,t){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},o.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="",o(o.s="./src/js/init/index.js")}({"./node_modules/babel-loader/lib/index.js?!./node_modules/mofron/src/core/namesp.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--4!./node_modules/mofron/src/core/namesp.js ***!
  \****************************************************************************************/
/*! no static exports found */function(module,exports){eval('/**\n * @file namespace.js\n * @author simpart\n */\n//const Window = require("./Window.js");\nmodule.exports = {\n  root: [],\n  window: null,\n  "class": {},\n  objkey: {},\n  util: {} //debug  : false\n\n};\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/namesp.js?./node_modules/babel-loader/lib??ref--4')},"./node_modules/babel-loader/lib/index.js?!./src/js/conf/namesp.js":
/*!***********************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--4!./src/js/conf/namesp.js ***!
  \***********************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("/**\n * @file namesp.js\n * @brief define namespace\n */\nvar mf = __webpack_require__(/*! mofron */ \"./node_modules/mofron/index.js\");\n/**\n * get GET parameter fron url\n */\n\n\nvar getParam = function getParam() {\n  try {\n    var ret = {};\n    var param = location.search.substring(1).split('&');\n\n    for (var loop = 0; loop < param.length; loop++) {\n      var key_srh = param[loop].search(/=/);\n      var key = -1 !== key_srh ? param[loop].slice(0, key_srh) : '';\n      var val = param[loop].slice(param[loop].indexOf('=', 0) + 1);\n\n      if ('' !== key) {\n        ret[key] = decodeURI(val);\n      }\n    }\n\n    return ret;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n/**\n * get hash value from url\n */\n\n\nvar getHash = function getHash() {\n  try {\n    var ret = window.location.hash.split('#')[1];\n    return undefined === ret ? null : ret;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n\nmodule.exports = {\n  //root : new mf.Component(),\n  conf: {\n    GET: getParam(),\n    hash: getHash()\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./src/js/conf/namesp.js?./node_modules/babel-loader/lib??ref--4")},"./node_modules/expose-loader/index.js?app!./src/js/conf/namesp.js-exposed":
/*!************************************************************************!*\
  !*** ./node_modules/expose-loader?app!./src/js/conf/namesp.js-exposed ***!
  \************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["app"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--4!./namesp.js */ "./node_modules/babel-loader/lib/index.js?!./src/js/conf/namesp.js");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:///./src/js/conf/namesp.js-exposed?./node_modules/expose-loader?app')},"./node_modules/expose-loader/index.js?mofron!./node_modules/mofron/src/core/namesp.js-exposed":
/*!********************************************************************************************!*\
  !*** ./node_modules/expose-loader?mofron!./node_modules/mofron/src/core/namesp.js-exposed ***!
  \********************************************************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["mofron"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--4!./namesp.js */ "./node_modules/babel-loader/lib/index.js?!./node_modules/mofron/src/core/namesp.js");\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/namesp.js-exposed?./node_modules/expose-loader?mofron')},"./node_modules/mofron-comp-appbase/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron-comp-appbase/index.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file   mofron-comp-appbase/index.js\n * @brief  common application component for mofron\n *         it makes easy to build page.\n * @license MIT\n */\nvar Header = __webpack_require__(/*! mofron-comp-appheader */ "./node_modules/mofron-comp-appheader/index.js");\n\nvar Image = __webpack_require__(/*! mofron-comp-image */ "./node_modules/mofron-comp-image/index.js");\n\nvar Synwin = __webpack_require__(/*! mofron-effect-syncwin */ "./node_modules/mofron-effect-syncwin/index.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   *\n   * @param (mixed) title parameter\n   *                dict: component config list\n   * @param (component) child component\n   * @short title,child\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("AppBase");\n\n      _this.shortForm("title", "child");\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        this.header(new Header());\n        this.bgwrap(new mofron["class"].Component());\n        var conts = new mofron["class"].Component({\n          width: \'100%\'\n        });\n        this.child([this.header(), this.bgwrap(), conts]);\n        this.childDom(conts.childDom());\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set app title (header text)\n     *\n     * @param (mixed) string/mofron-comp-text: app title\n     * @param (mixed) string: path to app logo image\n     *                mofron-comp-image: logo image\n     * @return (mofron-comp-text) app title\n     * @type parameter\n     */\n\n  }, {\n    key: "title",\n    value: function title(prm, img) {\n      try {\n        var ret = this.header().title(prm);\n\n        if (undefined === prm) {\n          return ret;\n        }\n\n        this.header().image(img);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * app header\n     * \n     * @param (mofron-comp-header) header component\n     * @return (mofron-comp-header) header component\n     * @type parameter\n     */\n\n  }, {\n    key: "header",\n    value: function header(prm) {\n      try {\n        return this.innerComp(\'header\', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * background wrapper\n     *\n     * @param (component) background wrapper component\n     * @return (component) background wrapper component\n     * @type private\n     */\n\n  }, {\n    key: "bgwrap",\n    value: function bgwrap(prm) {\n      try {\n        if (true === comutl.isinc(prm, "Component")) {\n          prm.style({\n            "position": "relative",\n            "z-index": "-10"\n          });\n        }\n\n        return this.innerComp("bgwrap", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * background component\n     * height is synchronized with window height by auto\n     * \n     * @param (component) background component\n     * @return (component) background component\n     * @type parameter\n     */\n\n  }, {\n    key: "background",\n    value: function background(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          var ret = this.bgwrap().child();\n          return 0 === ret.length ? null : ret[0];\n        }\n        /* setter */\n\n\n        this.bgwrap().child(prm);\n        cmputl.rstyle(prm, {\n          \'position\': \'fixed\'\n        });\n        var off = comutl.getsize(this.header().height());\n        off = null !== off ? \'-\' + off.toPixel() + \'px\' : undefined;\n        prm.config({\n          effect: new Synwin({\n            y_offset: off\n          })\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * height\n     * \n     * @param (string (size)) height size\n     * @param (dict) style option\n     * @return (string) height size\n     * @type parameter\n     */\n\n  }, {\n    key: "height",\n    value: function height(prm, opt) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return comutl.sizesum(this.header().height(), _get(_getPrototypeOf(_class.prototype), "height", this).call(this));\n        }\n        /* setter */\n\n\n        var set_hei = comutl.getsize(comutl.sizediff(prm, this.header().height()));\n\n        _get(_getPrototypeOf(_class.prototype), "height", this).call(this, 0 > set_hei.value() ? prm : set_hei, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter header color\n     * \n     * @param (mixed (color)) string: color name, #hex\n     *                        array: [red, green, blue, alpha]\n     * @param (option) style option\n     * @return (string) color\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      try {\n        return this.header().baseColor(prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * background base color setter/getter\n     *\n     * @param (mixed (color)) string: color name, #hex\n     *                        array: [red, green, blue, alpha]\n     * @param (dict) style option\n     * @return (string) color\n     * @type parameter\n     */\n\n  }, {\n    key: "baseColor",\n    value: function baseColor(prm, opt) {\n      try {\n        return cmputl.color(this, \'background\', prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-appbase/index.js?')},"./node_modules/mofron-comp-appheader/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-comp-appheader/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n *  @file  mofron-comp-appheader/index.js\n *  @brief app header component for mofron\n *  @license MIT\n */\nvar Image = __webpack_require__(/*! mofron-comp-image */ "./node_modules/mofron-comp-image/index.js");\n\nvar Header = __webpack_require__(/*! mofron-comp-txtheader */ "./node_modules/mofron-comp-txtheader/index.js");\n\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nvar Link = __webpack_require__(/*! mofron-event-link */ "./node_modules/mofron-event-link/index.js");\n\nvar Synhei = __webpack_require__(/*! mofron-effect-synchei */ "./node_modules/mofron-effect-synchei/index.js");\n\nvar Hrzpos = __webpack_require__(/*! mofron-effect-hrzpos */ "./node_modules/mofron-effect-hrzpos/index.js");\n\nvar Horiz = __webpack_require__(/*! mofron-layout-horizon */ "./node_modules/mofron-layout-horizon/index.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_Header) {\n  _inherits(_class, _Header);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   * \n   * @param (mixed) mixed: title config parameter\n   *                dict: component config list\n   * @param (mixed) image config parameter\n   * @param (component) navi config parameter \n   * @short title,image,navi\n   * @type private\n   */\n  function _class(p1, p2, p3) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'AppHeader\');\n\n      _this.shortForm(\'title\', \'image\', \'navi\');\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2, p3);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * init dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        this.child(this.image(), 0);\n        this.image().event(new Link("./"));\n        this.text().event(new Link("./"));\n        var conts = new mofron["class"].Component({\n          layout: new Horiz()\n        });\n        this.child([conts, this.naviWrap()]);\n        this.styleDom(this.styleDom());\n        this.childDom(conts.childDom());\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * header title\n     *\n     * @param (mixed) string: header title\n     *                mofron-comp-text: replace title component of header\n     * @param (key-value) text config\n     * @return (mofron-comp-text) text contents\n     * @type parameter\n     */\n\n  }, {\n    key: "text",\n    value: function text(txt, cnf) {\n      try {\n        var ret = _get(_getPrototypeOf(_class.prototype), "text", this).call(this, txt, cnf);\n\n        if (undefined !== txt) {\n          this.text().style({\n            "margin-left": "0.2rem"\n          }, {\n            passive: true\n          });\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * header title, same as text\n     * \n     * @param (mixed) string: header title\n     *                mofron-comp-text: replace title component of header\n     * @param (key-value) text config\n     * @return (mofron-comp-text) text contents\n     * @type parameter\n     */\n\n  }, {\n    key: "title",\n    value: function title(txt, cnf) {\n      try {\n        return this.text(txt, cnf);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter logo image\n     * insert logo image to left side of title\n     *\n     * @param (mixed) string: path to logo image\n     *                mofron-comp-image: replace image component\n     * @param (key-value) image config\n     * @return (mofron-comp-image) logo image\n     * @type parameter\n     */\n\n  }, {\n    key: "image",\n    value: function image(prm, cnf) {\n      try {\n        if (undefined !== cnf) {\n          var add_cnf = true === comutl.isinc(prm, \'Image\') ? prm : this.image();\n          add_cnf.config(cnf);\n        }\n\n        if (\'string\' === typeof prm) {\n          this.image().config({\n            path: prm\n          });\n          return;\n        } else if (true === comutl.isinc(prm, \'Image\')) {\n          prm.config({\n            effect: new Synhei(this)\n          });\n          prm.style({\n            "margin-left": "0.1rem"\n          }, {\n            passive: true\n          });\n        }\n\n        return this.innerComp(\'image\', prm, Image);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter navigate area\n     *\n     * @param (component) navigate component\n     * @return (array) navigate component list\n     * @type parameter\n     */\n\n  }, {\n    key: "navi",\n    value: function navi(prm) {\n      try {\n        return this.naviWrap().child(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * logo image position and size offset\n     * \n     * @param (string (size)) left offset position\n     * @param (string (size)) height offset position\n     * \n     */\n\n  }, {\n    key: "imgpos",\n    value: function imgpos(lft, hei) {\n      try {\n        this.image().style({\n          "margin-left": lft\n        });\n        var syn = this.image().effect({\n          name: "SyncHei"\n        });\n\n        if (true === comutl.isinc(syn, "SyncHei")) {\n          syn.offset(hei);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter url jump target\n     * it jump to this url when user clicks logo or title\n     * set null if you don\'t want jump\n     * \n     * @param (mixed) string: jump url\n     *                null: not jump\n     * @return (string) jump url\n     * @type parameter\n     */\n\n  }, {\n    key: "url",\n    value: function url(prm) {\n      try {\n        var txt_link = this.text().event({\n          name: "Link"\n        });\n        var img_link = this.image().event({\n          name: "Link"\n        });\n\n        if (undefined === prm) {\n          return "" === txt_link.url() ? null : txt_link.url();\n        }\n\n        if (null === prm) {\n          txt_link.config({\n            url: "",\n            suspend: true\n          });\n          img_link.config({\n            url: "",\n            suspend: true\n          });\n        } else {\n          txt_link.url(prm);\n          img_link.url(prm);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter navigate wrapper\n     * \n     * @param (component) wrap component\n     * @return (component) wrap component\n     * @type private\n     */\n\n  }, {\n    key: "naviWrap",\n    value: function naviWrap(prm) {\n      try {\n        if (true === comutl.isinc(prm, \'Component\')) {\n          prm.config({\n            layout: new Horiz(),\n            effect: new Hrzpos("right", "0.2rem")\n          });\n        }\n\n        return this.innerComp(\'naviWrap\', prm, mofron["class"].Component);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Header);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-appheader/index.js?')},"./node_modules/mofron-comp-circle/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-comp-circle/index.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-comp-circle/index.js\n * @brief menu item component for mofron\n *        this is interface component\n * @license MIT\n */\nvar Frame = __webpack_require__(/*! mofron-comp-frame */ "./node_modules/mofron-comp-frame/index.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_Frame) {\n  _inherits(_class, _Frame);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   * \n   * @param (dict) component config\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Circle");\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * circle size setter/getter\n   * \n   * @param (string(size)) circle size\n   * @param (none) for super class, not use\n   * @return (string(size)) circle size\n   * @type parameter\n   */\n\n\n  _createClass(_class, [{\n    key: "size",\n    value: function size(x, y) {\n      try {\n        var ret = this.width(x);\n\n        if (undefined === x) {\n          return ret;\n        }\n\n        _get(_getPrototypeOf(_class.prototype), "height", this).call(this, x);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * circle size setter/getter\n     *\n     * @param (string(size)) circle size\n     * @param (dict) style option\n     * @return (string(size)) circle size\n     * @type parameter\t\t\t      \n     */\n\n  }, {\n    key: "width",\n    value: function width(prm, opt) {\n      try {\n        var ret = _get(_getPrototypeOf(_class.prototype), "width", this).call(this, prm, opt);\n\n        if (undefined === prm) {\n          return ret;\n        }\n\n        var siz = comutl.getsize(prm);\n        siz.value(siz.value() / 2);\n        this.radius(siz.toString());\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * circle size setter/getter\n     *\n     * @param (string(size)) circle size\n     * @param (dict) style option\n     * @return (string(size)) circle size\n     * @type parameter                        \n     */\n\n  }, {\n    key: "height",\n    value: function height(prm, opt) {\n      try {\n        var ret = _get(_getPrototypeOf(_class.prototype), "height", this).call(this, prm, opt);\n\n        if (undefined === prm) {\n          return ret;\n        }\n\n        var siz = comutl.getsize(prm);\n        siz.value(siz.value() / 2);\n        this.radius(siz.toString());\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Frame);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-circle/index.js?')},"./node_modules/mofron-comp-frame/index.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron-comp-frame/index.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file   mofron-comp-frame/index.js\n * @brief  frame component for mofron\n * @feature default size is 1rem Ã— 1rem\n *          frame size is includes border size\n * @license MIT\n */\nvar Radius = __webpack_require__(/*! mofron-effect-radius */ "./node_modules/mofron-effect-radius/index.js");\n\nvar Shadow = __webpack_require__(/*! mofron-effect-shadow */ "./node_modules/mofron-effect-shadow/index.js");\n\nvar Border = __webpack_require__(/*! mofron-effect-border */ "./node_modules/mofron-effect-border/index.js");\n\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize frame component\n   * \n   * @param (mixed) width parameter\n   *                key-value: component option\n   * @param (string (size)) height parameter\n   * @short width,height\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Frame");\n\n      _this.shortForm("width", "height");\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n        /* configure border style */\n\n\n        this.effect([new Border({\n          color: [190, 190, 190],\n          tag: "Frame"\n        }), new Radius("0rem"), new Shadow("0rem")]);\n        this.childDom().style().listener("border-width", function (p1, p2, p3) {\n          try {\n            var o_bdr = comutl.sizesum(p2["border-width"], p2["border-width"]);\n            p3.size(comutl.sizesum(cmputl.size(p3, "width"), o_bdr), comutl.sizesum(cmputl.size(p3, "height"), o_bdr));\n          } catch (e) {}\n        }, this);\n        this.size("1rem", "1rem");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * background color\n     * \n     * @param (mixed (color)) string: background color name, #hex\n     *                        array: [red, green, blue, (alpha)]\n     * @param (key-value) style option\n     * @return (string) background color\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      try {\n        return cmputl.color(this, "background", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border color\n     * \n     * @param (mixed (color)) string: border color name, #hex\n     *                        array: [red, green, blue, (alpha)]\n     * @return (mixed (color)) border color\n     * @type parameter\n     */\n\n  }, {\n    key: "accentColor",\n    value: function accentColor(prm, opt) {\n      try {\n        this.effect({\n          name: "Shadow"\n        }).color(prm);\n        return this.effect({\n          name: "Border"\n        }).color(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * radius effect\n     *\n     * @param (string (size)) radius effect value\n     * @return (string (size)) radius effect value\n     * @type parameter\n     */\n\n  }, {\n    key: "radius",\n    value: function radius(prm) {\n      try {\n        return this.effect({\n          name: "Radius"\n        }).value(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * shadow effect\n     *\n     * @param (string (size)) shadow value\n     * @return (string (size)) shadow value\n     * @type parameter\n     */\n\n  }, {\n    key: "shadow",\n    value: function shadow(prm) {\n      try {\n        return this.effect({\n          name: "Shadow"\n        }).value(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * frame width\n     * \n     * @param (string (size)) frame width\n     * @param (key-value) style option\n     * @return (string (size)) frame width\n     * @type parameter\n     */\n\n  }, {\n    key: "width",\n    value: function width(prm, opt) {\n      try {\n        return this.frmsiz("width", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * frame height\n     * \n     * @param (string (size)) frame height\n     * @param (key-value) style option\n     * @return (string (size)) frame height\n     * @type parameter\n     */\n\n  }, {\n    key: "height",\n    value: function height(prm, opt) {\n      try {\n        return this.frmsiz("height", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set frame size\n     * \n     * @param (string) size target (width,height)\n     * @type private\n     */\n\n  }, {\n    key: "frmsiz",\n    value: function frmsiz(tgt, val, opt) {\n      try {\n        if ("width" !== tgt && "height" !== tgt) {\n          throw new Error("invalid parameter");\n        }\n\n        var bdr_siz = this.effect({\n          name: "Border",\n          tag: "Frame"\n        }).width();\n        bdr_siz = comutl.sizesum(bdr_siz, bdr_siz);\n\n        if (undefined === val) {\n          /* getter */\n          return comutl.sizesum(_get(_getPrototypeOf(_class.prototype), tgt, this).call(this), bdr_siz);\n        }\n        /* setter */\n\n\n        _get(_getPrototypeOf(_class.prototype), tgt, this).call(this, comutl.sizesum(val, null === bdr_siz ? null : "-" + bdr_siz));\n      } catch (e) {\n        return _get(_getPrototypeOf(_class.prototype), tgt, this).call(this, val);\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-frame/index.js?')},"./node_modules/mofron-comp-header/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-comp-header/index.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file   mofron-comp-header/index.js\n * @brief  header component for mofron\n *         This component for placing at the top of the page etc. and displaying the site title etc.\n * @feature A header\'s child components are placed horizontally since header has a horizon layout.\n * @attention it maybe needs a \'false\' config at bind parameter that used as a child component.\n * @license MIT\n */\nvar Horizon = __webpack_require__(/*! mofron-layout-horizon */ "./node_modules/mofron-layout-horizon/index.js");\n\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * constructor\n   * \n   * @param (mixed) child parameter\n   *                key-value: component config\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n      /* init config */\n\n      _this.name("Header");\n\n      _this.confmng().add("wrap", {\n        type: "Dom"\n      });\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        var wrap = new mofron["class"].Component();\n        this.child(wrap);\n        this.childDom(wrap.childDom());\n        this.layout(new Horizon());\n        /* border config */\n\n        this.style({\n          "border-bottom-style": "solid",\n          "border-bottom-width": "0.01rem"\n        });\n        this.size("100%", "0.5rem");\n        this.bind(true);\n        this.mainColor([211, 211, 211]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * header height\n     * \n     * @param (string (size)) header height (default is "0.5rem")\n     * @param (option) style option\n     * @return (string (size)) header height\n     * @type parameter\n     */\n\n  }, {\n    key: "height",\n    value: function height(val, opt) {\n      try {\n        if (undefined === val) {\n          return this.rootDom()[0].style("height");\n        }\n\n        cmputl.rstyle(this, {\n          height: val\n        }, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * binding header \n     * \n     * @param (boolean) true: header position is fixed. display header even if user scrolls. (default)\n     *                  false: header position is not fixed.\n     * @return (boolean) binding config\n     * @type parameter\n     */\n\n  }, {\n    key: "bind",\n    value: function bind(flg) {\n      try {\n        if (undefined === flg) {\n          /* getter */\n          return \'fixed\' === this.style(\'position\') ? true : false;\n        }\n        /* setter */\n\n\n        if (\'boolean\' !== typeof flg) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        if (true === flg) {\n          this.style({\n            \'position\': \'fixed\',\n            \'z-index\': 999\n          });\n        } else {\n          this.style({\n            position: null\n          }, \'fixed\' === this.style(\'position\') ? false : true);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border bottom color\n     *\n     * @param (mixed (color)) string: border bottom color name, #hex\n     *                        array: [red, green, blue, (alpha)]\n     * @param (key-value) stye option\n     * @return (string) border bottom color\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      try {\n        return cmputl.color(this, "border-bottom-color", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-header/index.js?')},"./node_modules/mofron-comp-image/index.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron-comp-image/index.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-comp-image/index.js\n * @brief image component for mofron\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize image component\n   *\n   * @param (mixed) path parameter\n   *                key-value: component option\n   * @short path\n   * @type private\n   */\n  function _class(p1) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Image");\n\n      _this.shortForm("path");\n\n      if (0 < arguments.length) {\n        _this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   *\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this, \'img\');\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * image path\n     *\n     * @param (string) path to image\n     * @return (string) path to image\n     * @type parameter\n     */\n\n  }, {\n    key: "path",\n    value: function path(prm) {\n      try {\n        return this.value(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * base64 image value\n     *\n     * @param (number) base64 image value\n     * @return (number) base64 image value\n     * @type parameter\n     */\n\n  }, {\n    key: "base64",\n    value: function base64(prm) {\n      try {\n        return this.value(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * src value of dom attribute\n     * \n     * @param (string) path to image file\n     * @return (string) path to image file\n     * @type parameter\n     */\n\n  }, {\n    key: "src",\n    value: function src(prm) {\n      try {\n        return this.value(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * src value of dom attribute\n     * \n     * @param (mixed) string: path to image\n     *                number: base64 value\n     * @return (mixed) src value of dom attribute\n     * @type private\n     */\n\n  }, {\n    key: "value",\n    value: function value(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return this.target().attr(\'src\');\n        }\n        /* setter */\n\n\n        if (\'string\' !== typeof prm && \'number\' !== typeof prm) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.childDom().attrs({\n          src: prm\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-image/index.js?')},"./node_modules/mofron-comp-menu/index.js":
/*!************************************************!*\
  !*** ./node_modules/mofron-comp-menu/index.js ***!
  \************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-comp-menu/index.js\n * @brief menu component for mofron \n * @feature configure the displayed contents when users click the menu by "contents" parameter\n *          "horizon" parameter is config that is horizontal menu item or vertical menu item\n * @license MIT\n */\nvar Click = __webpack_require__(/*! mofron-event-click */ "./node_modules/mofron-event-click/index.js");\n\nvar Relat = __webpack_require__(/*! mofron-layout-relative */ "./node_modules/mofron-layout-relative/index.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize menu component\n   *\n   * @param (mixed) item parameter\n   *                object: component option\n   * @short item\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Menu");\n\n      _this.shortForm("item");\n      /* init config */\n\n\n      _this.confmng().add("item", {\n        type: "Component",\n        list: true\n      });\n\n      _this.confmng().add("reselect", {\n        type: "boolean",\n        init: false\n      });\n\n      _this.confmng().add("select", {\n        type: "number",\n        init: 0\n      });\n\n      _this.confmng().add("selectEvent", {\n        type: "event",\n        list: true\n      });\n\n      _this.confmng().add("mainColor", {\n        type: "color"\n      });\n\n      _this.confmng().add("baseColor", {\n        type: "color"\n      });\n\n      _this.confmng().add("accentColor", {\n        type: "color"\n      });\n\n      _this.confmng().add("mainColor_opt", {\n        type: "object"\n      });\n\n      _this.confmng().add("baseColor_opt", {\n        type: "object"\n      });\n\n      _this.confmng().add("accentColor_opt", {\n        type: "object"\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   *\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        this.layout(new Relat({\n          value: "0px",\n          tag: "Menu"\n        }));\n        /* set select event */\n\n        var sel_evt = function sel_evt(s1, s2, s3) {\n          try {\n            var itm = s1.item();\n\n            for (var iidx in itm) {\n              if (false === comutl.isinc(itm[iidx], "MenuItem")) {\n                continue;\n              }\n\n              itm[iidx].select(iidx == s2 ? true : false);\n            }\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n\n        this.selectEvent(sel_evt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * init size\n     *\n     * @type private\n     */\n\n  }, {\n    key: "beforeRender",\n    value: function beforeRender() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "beforeRender", this).call(this);\n        /* set color */\n\n\n        var itm = this.item();\n\n        for (var iidx in itm) {\n          if (null !== this.mainColor()) {\n            itm[iidx].mainColor(this.mainColor(), null === this.confmng("mainColor_opt") ? undefined : this.confmng("mainColor_opt"));\n          }\n\n          if (null !== this.baseColor()) {\n            itm[iidx].baseColor(this.baseColor(), null === this.confmng("baseColor_opt") ? undefined : this.confmng("baseColor_opt"));\n          }\n\n          if (null !== this.accentColor()) {\n            itm[iidx].accentColor(this.accentColor(), null === this.confmng("accentColor_opt") ? undefined : this.confmng("accentColor_opt"));\n          }\n        }\n        /* init size */\n\n\n        this.initSize("width", true);\n        this.initSize("height", false);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * initialize size\n     * \n     * @param (string) size type ("width"/"height")\n     * @param (boolean) horizon type\n     * @type private\n     */\n\n  }, {\n    key: "initSize",\n    value: function initSize(prm, hrz) {\n      try {\n        var siz = comutl.getsize(this[prm]());\n        var itm = this.item();\n\n        if (0 === itm.length) {\n          console.warn("there is no items");\n          return;\n        }\n\n        if (null !== siz) {\n          if (hrz === this.horizon() && 0 !== itm.length) {\n            siz.value(siz.value() / itm.length);\n          }\n\n          for (var sidx in itm) {\n            itm[sidx][prm](siz.toString());\n          }\n        } else {\n          /* size config is null, set value from items */\n          if (hrz === this.horizon() && 0 !== itm.length) {\n            var set_siz = null;\n\n            for (var _sidx in itm) {\n              set_siz = comutl.sizesum(set_siz, itm[_sidx][prm]());\n            }\n          } else {\n            this[prm](itm[0][prm]());\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * selected initialize menu item\n     * add contents switch\n     *\n     * @type private\n     */\n\n  }, {\n    key: "afterRender",\n    value: function afterRender() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "afterRender", this).call(this);\n        /* defalut selected */\n\n\n        if (undefined !== this.item()[this.select()]) {\n          this.item()[this.select()].eventDom().getRawDom().click();\n          var evt = this.selectEvent();\n\n          for (var eidx in evt) {\n            evt[eidx][0](this, this.select(), evt[eidx][1]);\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set/unset horizontal mode\n     * menu item is added in the horizontal direction if p1 setted true\n     *\n     * @param (boolean) set/unset horizontal mode\n     * @return (boolean) horizontal mode status\n     * @type parameter\n     */\n\n  }, {\n    key: "horizon",\n    value: function horizon(flg) {\n      try {\n        if (undefined === flg) {\n          /* getter */\n          return \'flex\' === this.style(\'display\') ? true : false;\n        }\n        /* setter */\n\n\n        this.style({\n          \'display\': true === flg ? \'flex\' : null\n        });\n        var relat = this.layout({\n          name: "Relative",\n          tag: "Menu"\n        });\n\n        if (null === relat) {\n          return;\n        }\n\n        relat.type(true === flg ? "left" : "top");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * select menu item\n     *\n     * @param (number) select menu item index\n     * @return (number) selected menu item index\n     * @type parameter\n     */\n\n  }, {\n    key: "select",\n    value: function select(idx) {\n      try {\n        if (undefined === idx) {\n          /* getter */\n          return this.confmng("select");\n        }\n        /* setter */\n\n\n        if (true === this.reselect() || idx !== this.select()) {\n          this.confmng("select", idx);\n          var evt = this.selectEvent();\n\n          for (var eidx in evt) {\n            evt[eidx][0](this, idx, evt[eidx][1]);\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * reselect flag setter/getter\n     * \n     * @param (boolean) true: call event when items are duplicates selected\n     *                  false: ignored when items are duplicates selected [default]\n     * @return (boolean) reselect flag\n     * @type parameter\n     */\n\n  }, {\n    key: "reselect",\n    value: function reselect(prm) {\n      try {\n        return this.confmng("reselect", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * select event\n     *\n     * @param (function) select event function\n     * @param (mixed) select event parameter\n     * @return (array) select event [[function, parameter], ...]\n     * @type parameter\n     */\n\n  }, {\n    key: "selectEvent",\n    value: function selectEvent(fnc, prm) {\n      try {\n        return this.confmng("selectEvent", fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * menu item\n     *\n     * @param (mixed) component: menu items component\n     *                array: menu items list\n     * @return (array) menu items list\n     * @type parameter\n     */\n\n  }, {\n    key: "item",\n    value: function item(prm, opt) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return this.confmng("item", prm);\n        }\n        /* setter */\n\n\n        if (true === Array.isArray(prm)) {\n          for (var pidx in prm) {\n            this.item(prm[pidx], opt);\n          }\n\n          return;\n        }\n\n        var menu = this;\n\n        var clk = function clk(cp1, cp2, cp3) {\n          try {\n            var itm = menu.item();\n\n            for (var iidx in itm) {\n              if (cp1.id() === itm[iidx].id()) {\n                menu.select(parseInt(iidx));\n              }\n            }\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n\n        prm.config({\n          event: new Click(clk)\n        });\n\n        if (undefined !== opt) {\n          prm.config(opt);\n        }\n\n        this.child(prm);\n        this.confmng("item", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * offset position of menu item\n     * \n     * @param (string(size)) offset value\n     * @return (string(size)) offset value\n     * @type parameter\n     */\n\n  }, {\n    key: "offset",\n    value: function offset(prm) {\n      try {\n        var relat = this.layout({\n          name: "Relative",\n          tag: "Menu"\n        });\n        return null !== relat ? relat.value(prm) : null;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * main color of items\n     *\n     * @param (mixed) string: menu item color name, #hex\n     *                array: [red, green, blue, (alpha)]\n     * @param (option) style option\n     * @return (string) menu item main color\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      try {\n        this.confmng("mainColor_opt", opt);\n        return this.confmng("mainColor", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * base color of items\n     *\n     * @param (mixed) string: color name, #hex\n     *                array: [red, green, blue, (alpha)]\n     * @param (option) style option\n     * @return (string) menu item base color\n     * @type parameter\n     */\n\n  }, {\n    key: "baseColor",\n    value: function baseColor(prm, opt) {\n      try {\n        this.confmng("baseColor_opt", opt);\n        return this.confmng("baseColor", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * accent color of items\n     *\n     * @param (mixed) string: color name, #hex\n     *                array: [red, green, blue, (alpha)]\n     * @param (option) style option\n     * @return (string) menu item accent color\n     * @type parameter\n     */\n\n  }, {\n    key: "accentColor",\n    value: function accentColor(prm, opt) {\n      try {\n        this.confmng("accentColor_opt", opt);\n        return this.confmng("accentColor", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-menu/index.js?')},"./node_modules/mofron-comp-slidemenu/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-comp-slidemenu/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-comp-slidemenu/index.js\n * @brief slidemenu component for mofron\n * @license MIT\n */\nvar Menu = __webpack_require__(/*! mofron-comp-menu */ "./node_modules/mofron-comp-menu/index.js");\n\nvar Border = __webpack_require__(/*! mofron-effect-border */ "./node_modules/mofron-effect-border/index.js");\n\nvar Focus = __webpack_require__(/*! mofron-event-clkfocus */ "./node_modules/mofron-event-clkfocus/index.js");\n\nvar Position = __webpack_require__(/*! mofron-effect-position */ "./node_modules/mofron-effect-position/index.js");\n\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_Menu) {\n  _inherits(_class, _Menu);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   * \n   * @param (mixed) item parameter\n   *                dict: component config\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("SlideMenu");\n      /* init config */\n\n\n      _this.confmng().add("position", {\n        type: "string",\n        select: ["left", "right"],\n        init: "left"\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   *\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n        /* focus event */\n\n\n        var fcs = function fcs(f1, f2) {\n          try {\n            f1.visible(false);\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n        /* set default config */\n\n\n        this.config({\n          style: {\n            "position": "fixed",\n            "top": "0rem",\n            "z-index": "999"\n          },\n          event: new Focus({\n            tag: "SlideMenu",\n            listener: fcs,\n            pointer: false\n          }),\n          effect: [new Border(), new Position({\n            tag: "SlideMenu",\n            value: "0rem",\n            eid: 0\n          }), new Position({\n            tag: "SlideMenu",\n            eid: 1\n          })],\n          visible: false\n        });\n        /* display event */\n\n        var disp = function disp(d1, d2, d3) {\n          if ("none" !== d2[0]) {\n            setTimeout(function () {\n              d3.event({\n                name: "ClkFocus",\n                tag: "SlideMenu"\n              }).status(true);\n            }, 50);\n          } else {\n            setTimeout(function () {\n              d3.event({\n                name: "ClkFocus",\n                tag: "SlideMenu"\n              }).status(false);\n            }, 50);\n          }\n        };\n\n        this.styleDom().style().listener("display", disp, this);\n        /* add select event */\n\n        var sel = function sel(s1, s2) {\n          try {\n            s1.visible(false);\n            setTimeout(function () {\n              s1.event({\n                name: "ClkFocus",\n                tag: "SlideMenu"\n              }).status(false);\n            }, 50);\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n\n        this.selectEvent(sel);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * init menu position\n     * \n     * @type private\n     */\n\n  }, {\n    key: "beforeRender",\n    value: function beforeRender() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "beforeRender", this).call(this);\n        /* set initial position */\n\n\n        var pcnf = this.confmng("position");\n\n        if ("left" === pcnf) {\n          this.style({\n            "left": "-" + this.width()\n          });\n        } else {\n          this.style({\n            "right": "-" + this.width()\n          });\n        }\n        /* set position value */\n\n\n        this.effect({\n          name: "Position",\n          tag: "SlideMenu",\n          eid: 1\n        }).value("-" + this.width());\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set height\n     * \n     * @type private\n     */\n\n  }, {\n    key: "afterRender",\n    value: function afterRender() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "afterRender", this).call(this);\n\n        cmputl.size(this, "height", "100%");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * menu position setter/getter\n     * \n     * @param (string) left: slides from the left side [default]\n     *                 right: slides from the right side\n     * @return (string) menu position\n     * @type parameter\n     */\n\n  }, {\n    key: "position",\n    value: function position(prm) {\n      try {\n        var ret = this.confmng("position", prm);\n\n        if (undefined !== prm) {\n          this.effect({\n            name: "Position",\n            tag: "SlideMenu",\n            eid: 0\n          }).direction(prm);\n          this.effect({\n            name: "Position",\n            tag: "SlideMenu",\n            eid: 1\n          }).direction(prm);\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * menu panel setter/getter\n     * \n     * @param (mixed(color)) string: background color name, #hex\n     *                       array: [red, green, blue, (alpha)]\n     * @param (dict) style option\n     * @type parameter\n     */\n\n  }, {\n    key: "baseColor",\n    value: function baseColor(prm, opt) {\n      try {\n        return cmputl.color(this, "background", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Menu);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-slidemenu/index.js?')},"./node_modules/mofron-comp-text/index.js":
/*!************************************************!*\
  !*** ./node_modules/mofron-comp-text/index.js ***!
  \************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file   mofron-comp-text/index.js\n * @brief  text component for mofron\n * @license MIT\n */\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nvar Font = __webpack_require__(/*! mofron-effect-font */ "./node_modules/mofron-effect-font/index.js");\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * constructor\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: component config\n   * @short text\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Text\');\n\n      _this.shortForm(\'text\');\n      /* init config */\n\n\n      _this.confmng().add("heiWeight", {\n        init: 1.5,\n        type: "number"\n      });\n\n      _this.confmng().add("weight", {\n        type: "number",\n        select: [100, 200, 300, 400, 500, 600, 700, 800, 900]\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        this.effect(new Font({\n          tag: "Text",\n          suspend: true\n        }));\n        this.text(\'\'); // default text\n\n        this.size("0.16rem"); // default size\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text setter/getter\n     * \n     * @param (mixed) string: text value\n     *                undefined: call as getter\n     * @return (string) text value\n     * @type parameter\n     */\n\n  }, {\n    key: "text",\n    value: function text(val) {\n      try {\n        return this.childDom().text(val);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text getter\n     * \n     * @return (string) text value\n     * @type function\n     */\n\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        return this.text();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text size setter/getter\n     *\n     * @param (mixed) string (size): text size\n     *                undefined: call as getter\n     * @param (key-value) style option [not required]\n     * @return (mixed) string: text size (default is "0.16rem")\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "size",\n    value: function size(val, opt) {\n      try {\n        return cmputl.size(this, "font-size", val, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text height setter/getter\n     * \n     * @param (mixed) string (size): text size\n     *                undefined: call as getter\n     * @param (key-value) style option [not required]\n     * @return (mixed) string: text height (default is "0.24rem")\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "height",\n    value: function height(prm, opt) {\n      try {\n        var siz = comutl.getsize(undefined === prm ? this.size() : prm);\n        var siz_buf = null;\n\n        if (\'rem\' === siz.type() || \'px\' === siz.type()) {\n          if (undefined === prm) {\n            siz_buf = siz.value() * this.heiWeight();\n          } else {\n            siz_buf = siz.value() / this.heiWeight();\n          }\n\n          siz_buf = comutl.roundup(siz_buf) + siz.type();\n        } else {\n          siz_buf = siz.toString();\n        }\n\n        if (undefined === prm) {\n          /* gettter */\n          return siz_buf;\n        }\n\n        this.size(siz_buf, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * height weight setter/getter\n     * this value to make \'height\' parameter and real dom size the same\n     * it needs to adjust depending on font difference.\n     * \n     * @param (mixed) number: height weight rate\n     *                undefined: call as getter\n     * @return (number) height weight rate\n     * @type private\n     */\n\n  }, {\n    key: "heiWeight",\n    value: function heiWeight(prm) {\n      try {\n        return this.confmng("heiWeight", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text color setter/getter\n     * \n     * @param (mixed (color)) string: color name, #hex\n     *                array: [red, green, blue, (alpha)]\n     * @param (key-value) style option [not required]\n     * @return (mixed) string: text color\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(val, opt) {\n      try {\n        return cmputl.color(this, \'color\', val, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text font setter/getter\n     * \n     * @param (mixed) string: font name\n     *                undefined: call as getter\n     * @param (string) path to font file [not required]\n     * @return (mixed) array: font name\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "font",\n    value: function font(fnm, pth) {\n      try {\n        var font = this.effect({\n          name: "Font",\n          tag: "Text"\n        });\n\n        if (undefined === fnm) {\n          /* getter */\n          return font.fname();\n        }\n        /* setter */\n\n\n        font.suspend(false);\n\n        if ("string" === typeof fnm) {\n          font.fname(fnm);\n        } else if (true === Array.isArray(fnm) && 2 === fnm.length) {\n          font.fname(fnm[0], fnm[1]);\n        } else {\n          throw new Error("invalid parameter");\n        }\n\n        font.path(pth);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * character spacing setter/getter\n     *\n     * @param (mixed) string(size): spacing size\n     *                undefined: call as getter\n     * @param (key-value) style option [not required]\n     * @return (mixed) string: spacing size\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "space",\n    value: function space(val, opt) {\n      try {\n        return cmputl.size(this, \'letter-spacing\', val, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text thickness setter/getter\n     *\n     * @param (mixed) number: thickness value [100-900]\n     *                null: delete thickness\n     *                undefined: call as getter\n     * @param (key-value) style option [not required]\n     * @return (number) thickness value\n     * @type parameter\n     */\n\n  }, {\n    key: "weight",\n    value: function weight(val, opt) {\n      try {\n        if (undefined === val) {\n          /* getter */\n          return this.style("font-weight");\n        }\n        /* setter */\n\n\n        this.style({\n          \'font-weight\': val\n        }, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-text/index.js?')},"./node_modules/mofron-comp-txtframe/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-comp-txtframe/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-comp-txtframe/index.js\n * @brief text frame component for mofron\n *        text contents in the frame component.\n * @feature text is automatically centered\n *          center position can select vertical or horizonal by center parameter\n * @license MIT\n */\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nvar Frame = __webpack_require__(/*! mofron-comp-frame */ "./node_modules/mofron-comp-frame/index.js");\n\nvar Vrtpos = __webpack_require__(/*! mofron-effect-vrtpos */ "./node_modules/mofron-effect-vrtpos/index.js");\n\nvar Hrzpos = __webpack_require__(/*! mofron-effect-hrzpos */ "./node_modules/mofron-effect-hrzpos/index.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_Frame) {\n  _inherits(_class, _Frame);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   * \n   * @param (mixed) text parameter\n   *                key-value: component config\n   * @short text\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("TxtFrame");\n\n      _this.shortForm("text");\n      /* init config */\n\n\n      _this.confmng().add("text", {\n        type: "Text"\n      });\n\n      _this.confmng().add("xCenter", {\n        type: "boolean",\n        init: true\n      });\n\n      _this.confmng().add("yCenter", {\n        type: "boolean",\n        init: true\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        this.style({\n          "display": "grid"\n        });\n        /* set text component */\n\n        this.text(new Text());\n        this.child(this.text());\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set center config\n     * \n     * @type private\n     */\n\n  }, {\n    key: "beforeRender",\n    value: function beforeRender() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "beforeRender", this).call(this);\n\n        this.centerConf();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text contents setter/getter\n     *\n     * @param (mixed) string: contents text\n     *                mofron-comp-text: contents component\n     *                undefined: call as getter\n     * @return (mofron-comp-text) contents component\n     * @type parameter\n     */\n\n  }, {\n    key: "text",\n    value: function text(prm, cnf) {\n      try {\n        if ("string" === typeof prm) {\n          this.text().text(prm);\n          this.text().config(cnf);\n          return;\n        }\n\n        return this.innerComp("text", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * center position of text contents setter/getter\n     *\n     * @param (boolean) horizonal center position flag\n     *                  undefined: call as getter\n     * @param (boolean) vertical center position flag\n     *                  undefined: call as getter\n     * @return (array) center position flags\n     * @type parameter\n     */\n\n  }, {\n    key: "center",\n    value: function center(x, y) {\n      try {\n        return [this.xCenter(x), this.yCenter(y)];\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * horizonal center position of text contents setter/getter\n     *\n     * @param (boolean) true: text is centered horizontally (default)\n     *                  false: text is not centered\n     * @return (boolean) center position flag\n     * @type parameter\n     */\n\n  }, {\n    key: "xCenter",\n    value: function xCenter(prm) {\n      try {\n        return this.confmng("xCenter", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * vertical center position of text contents\n     *\n     * @param (boolean) true: text is centered vertically (default)\n     *                  false: text is not centered\n     * @return (boolean) center position flag\n     * @type parameter\n     */\n\n  }, {\n    key: "yCenter",\n    value: function yCenter(prm) {\n      try {\n        return this.confmng("yCenter", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set center config\n     * \n     * @type private\n     */\n\n  }, {\n    key: "centerConf",\n    value: function centerConf() {\n      try {\n        var cent = this.center();\n        var chd = this.child();\n\n        for (var cidx in chd) {\n          /* set horizonal center */\n          if (true === cent[0]) {\n            if (false === this.isExists()) {\n              chd[cidx].effect(new Hrzpos({\n                type: "center",\n                tag: "TxtFrame"\n              }));\n            } else {\n              chd[cidx].effect({\n                name: "HrzPos",\n                tag: "TxtFrame"\n              }).execute();\n            }\n          }\n          /* set vertical center */\n\n\n          if (true === cent[1]) {\n            if (false === this.isExists()) {\n              chd[cidx].effect(new Vrtpos({\n                type: "center"\n              }));\n            } else {\n              chd[cidx].effect({\n                name: "VrtPos",\n                tag: "TxtFrame"\n              }).execute();\n            }\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text color setter/getter\n     * \n     * @param (mixed (color)) string: color name, #hex\n     *                        array: [red, green, blue, alpha]\n     * @param (option) style option\n     * @return (string) text color\n     * @type parameter\n     */\n\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      try {\n        return this.text().mainColor(prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Frame);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-txtframe/index.js?')},"./node_modules/mofron-comp-txtheader/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-comp-txtheader/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file  mofron-comp-txtheader/index.js\n * @brief text header component\n *        text in this component is positioned centrally in vertical in automatically. \n * @license MIT\n */\nvar Header = __webpack_require__(/*! mofron-comp-header */ "./node_modules/mofron-comp-header/index.js");\n\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nvar Synhei = __webpack_require__(/*! mofron-effect-synchei */ "./node_modules/mofron-effect-synchei/index.js");\n\nvar cmputl = mofron.util.component;\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_Header) {\n  _inherits(_class, _Header);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize component\n   * \n   * @param (mixed) text parameter\n   *                key-value: component option\n   * @short text\n   * @type private\n   */\n  function _class(p1) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'TxtHeader\');\n\n      _this.shortForm(\'text\');\n\n      if (0 < arguments.length) {\n        _this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * initialize dom contents\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "initDomConts",\n    value: function initDomConts() {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "initDomConts", this).call(this);\n\n        this.style({\n          \'align-items\': \'center\'\n        });\n        this.child(this.text());\n        this.text().effect(new Synhei(this));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter text\n     *\n     * @param (mixed) string: text contents\n     *                mofron-comp-text: update text component\n     * @param (key-value) text config\n     * @return (mofron-comp-text) text contents\n     * @type parameter\n     */\n\n  }, {\n    key: "text",\n    value: function text(txt, cnf) {\n      try {\n        if (undefined !== cnf) {\n          if (true === comutl.isinc(txt, "Text")) {\n            txt.config(cnf);\n          } else {\n            this.text().config(cnf);\n          }\n        }\n\n        if (\'string\' === typeof txt) {\n          this.text().text(txt);\n          return;\n        }\n\n        return this.innerComp(\'text\', txt, Text);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text position and size offset\n     * \n     * @param (string (size)) left offset position\n     * @param (string (size)) height offset position\n     * \n     */\n\n  }, {\n    key: "txtpos",\n    value: function txtpos(lft, hei) {\n      try {\n        this.text().style({\n          "margin-left": lft\n        });\n        var syn = this.text().effect({\n          name: "SyncHei"\n        });\n\n        if (true === comutl.isinc(syn, "SyncHei")) {\n          syn.offset(hei);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Header);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-comp-txtheader/index.js?')},"./node_modules/mofron-effect-border/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-border/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports){eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-border/index.js\n * @brief border effect for mofron\n *        set border style to target component\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize effect\n   * \n   * @param (mixed) width parameter\n   *                key-value: effect config\n   * @param (mixed) color parameter\n   * @short width,color\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name('Border');\n\n      _this.shortForm('width', 'color');\n      /* init config */\n\n\n      _this.confmng().add('width', {\n        type: 'size',\n        init: \"0.01rem\"\n      });\n\n      _this.confmng().add('style', {\n        type: 'string',\n        init: 'solid',\n        select: ['none', 'hidden', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset', 'dashed', 'dotted']\n      });\n\n      _this.confmng().add('position', {\n        type: 'string',\n        init: 'all',\n        select: ['all', 'top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right']\n      });\n\n      _this.confmng().add('color', {\n        type: 'color',\n        init: [90, 90, 90]\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * effect config\n   * \n   * @param (component) effect target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: \"contents\",\n    value: function contents(cmp) {\n      try {\n        var set_style = {};\n        var pos = 'all' === this.position() ? 'border-' : 'border-' + this.position() + '-';\n        set_style[pos + 'width'] = this.width().toString();\n        set_style[pos + 'style'] = this.style();\n        set_style[pos + 'color'] = this.color().toString();\n        cmp.style(set_style);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border width\n     * \n     * @param (string) css value of border width\n     * @return (string) css value of border width\n     * @type parameter\n     */\n\n  }, {\n    key: \"width\",\n    value: function width(prm) {\n      try {\n        return this.confmng('width', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter border style\n     *\n     * @param (string) css value of border style (default is 'solid')\n     *                 ('none', 'hidden', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset', 'dashed', 'dotted')\n     * @return (string) css value of border style\n     * @type parameter\n     */\n\n  }, {\n    key: \"style\",\n    value: function style(prm) {\n      try {\n        return this.confmng('style', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border position\n     * \n     * @param (string) border target position (default is 'all')\n     *                 ('all', 'top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right')\n     * @return (string) css value of border type\n     * @type parameter\n     */\n\n  }, {\n    key: \"position\",\n    value: function position(prm) {\n      try {\n        return this.confmng('position', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * border color\n     * \n     * @param (mixed (color)) string: color name, #hex\n     *                        array: [red, green, blue, (alpha)]\n     * @return (mixed (color)) border color\n     * @type parameter\n     */\n\n  }, {\n    key: \"color\",\n    value: function color(prm) {\n      try {\n        return this.confmng('color', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron[\"class\"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-border/index.js?")},"./node_modules/mofron-effect-color/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron-effect-color/index.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-color/index.js\n * @brief color effect for mofron\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize effect\n   * \n   * @param (mixed) color parameter\n   *                dict: effect config\n   * @short color\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Color\');\n\n      _this.shortForm(\'color\');\n      /* init config */\n\n\n      _this.confmng().add("type", {\n        type: "string",\n        select: ["main", "base", "accent"],\n        init: "main"\n      });\n\n      _this.confmng().add("color", {\n        type: "color"\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * effet contents\n   * \n   * @param (mofron.class.Component) effect target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        cmp[this.type() + "Color"](this.color());\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * target color type setter/getter\n     * \n     * @param (string) color type [\'main\'/\'base\'/\'accent\']\n     * @return (string) color type\n     * @type parameter\n     */\n\n  }, {\n    key: "type",\n    value: function type(prm) {\n      try {\n        return this.confmng("type", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * effect color setter/getter\n     * \n     * @param (mixed(color)) effect color\n     * @return (string) color of style value\n     * @type parameter\n     */\n\n  }, {\n    key: "color",\n    value: function color(prm) {\n      try {\n        return this.confmng("color", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-color/index.js?')},"./node_modules/mofron-effect-font/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-effect-font/index.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-font/index.js\n * @brief set text font for mofron-comp-text component\n *        format configure for each file automatically if you use local font\n * @attention this effect is private, this function is included in text component. so you don\'t need to use directly\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize effect\n   * \n   * @param (mixed) fname parameter\n   *                key-value: effect config\n   * @param (string) path parameter\n   * @short fname,path\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Font");\n\n      _this.shortForm("fname", "path");\n      /* init config */\n\n\n      _this.confmng().add("fname", {\n        type: "array"\n      });\n\n      _this.confmng().add("path", {\n        type: "string"\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * font name setter/getter\n   *\n   * @param (mixed) string: primary font name\n   *                undefined: call as getter\n   * @param (string) secondary font name (not required)\n   * @return (array) font name [primary, secondary]\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  _createClass(_class, [{\n    key: "fname",\n    value: function fname(p1, p2) {\n      try {\n        if (0 === arguments.length) {\n          /* getter */\n          return this.confmng("fname");\n        }\n        /* setter */\n\n\n        if ("string" !== typeof p1 || undefined !== p2 && "string" !== typeof p2) {\n          throw new Error("invalid parameter");\n        }\n\n        var set_val = [undefined, undefined];\n        set_val[0] = -1 !== p1.indexOf(" ") ? "\'" + p1 + "\'" : p1;\n\n        if ("string" === typeof p2) {\n          set_val[1] = -1 !== p2.indexOf(" ") ? "\'" + p2 + "\'" : p2;\n        }\n\n        this.confmng("fname", set_val);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter path to font\n     * \n     * @param (mixed) string: path to font\n     *                undefined: call as getter\n     * @return (string) path to font\n     *                  null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "path",\n    value: function path(prm) {\n      try {\n        return this.confmng("path", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter path to font, same as path config\n     * \n     * @param (mixed) string: path to font\n     *                undefined: call as getter\n     * @return (string) path to font\n     *                  null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "src",\n    value: function src(prm) {\n      try {\n        return this.confmng("path", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set font-face setting in style tag\n     * \n     * @param (string) font-family value\n     * @type private\n     */\n\n  }, {\n    key: "addFontFace",\n    value: function addFontFace(fnm) {\n      try {\n        /* format */\n        var pth_spt = this.path().split(\'.\');\n        var format = \'\';\n\n        if (\'woff\' === pth_spt[pth_spt.length - 1]) {\n          format = "format(\'woff\')";\n        } else if (\'ttf\' === pth_spt[pth_spt.length - 1]) {\n          format = "format(\'truetype\')";\n        } else if (\'otf\' === pth_spt[pth_spt.length - 1]) {\n          format = "format(\'opentype\')";\n        } else if (\'eot\' === pth_spt[pth_spt.length - 1]) {\n          format = "format(\'embedded-opentype\')";\n        } else if (\'svg\' === pth_spt[pth_spt.length - 1] || \'svgz\' === pth_spt[pth_spt.length - 1]) {\n          format = "format(\'svg\')";\n        }\n\n        var val = "@font-face {";\n        val += "font-family:" + fnm + ",";\n        val += "src:" + "url(\'" + this.path() + "\') " + format + "}";\n        comutl.addhead("style", {\n          type: "text/css",\n          test: "test"\n        }, val);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set text font\n     *\n     * @param (mofron.class.Component) component object\n     * @type private\n     */\n\n  }, {\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        var fname = this.fname();\n\n        if (null === fname) {\n          throw new Error("could not find font name config");\n        }\n\n        var set_fnt = undefined === fname[1] ? fname[0] : fname[0] + \',\' + fname[1];\n\n        if (null !== this.path()) {\n          this.addFontFace(set_fnt);\n        }\n\n        cmp.style({\n          \'font-family\': set_fnt\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-font/index.js?')},"./node_modules/mofron-effect-hrzpos/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-hrzpos/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-hrzpos/index.js\n * @brief horizonal position effect for mofron component\n *        the component is positioned specified parameter that is \'center\' or \'left\' and \'right\'.\n * @license MIT\n */\nvar cmputl = mofron.util.component;\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize effect\n   * \n   * @param (mixed) type parameter\n   *                key-value: effect config\n   * @param (string) offset parameter\n   * @short type,offset\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'HrzPos\');\n\n      _this.shortForm(\'type\', \'offset\');\n      /* init config */\n\n\n      _this.confmng().add("offset", {\n        type: "size"\n      });\n\n      _this.confmng().add("type", {\n        type: "string",\n        init: "center",\n        select: ["center", "left", "right"]\n      });\n      /* set config */\n\n\n      _this.innerTgt(false);\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * effect contents\n   * \n   * @param (mofron.class.Component) effect target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        var rdom = cmp.rootDom();\n\n        for (var ridx in rdom) {\n          if (true === comutl.isinc(cmp, "Text")) {\n            /* set text component position */\n            this.txtpos(rdom[ridx]);\n            continue;\n          }\n          /* set other component position */\n\n\n          var cmp_pos = rdom[ridx].style("position");\n\n          if ("center" === this.type()) {\n            if ("fixed" === cmp_pos || "absolute" === cmp_pos) {\n              this.lftpos(rdom[ridx]);\n            } else {\n              rdom[ridx].style({\n                "display": "block"\n              });\n              this.mgnpos(rdom[ridx]);\n            }\n          } else {\n            if ("relative" === cmp_pos) {\n              this.mgnpos(rdom[ridx]);\n            } else if ("absolute" === cmp_pos || "fixed" === cmp_pos) {\n              this.lftpos(rdom[ridx]);\n            } else {\n              if (null !== cmp.parent()) {\n                rdom[ridx].style({\n                  "position": "relative"\n                });\n                this.mgnpos(rdom[ridx]);\n              } else {\n                rdom[ridx].style({\n                  "position": "absolute"\n                });\n                this.lftpos(rdom[ridx]);\n              }\n            }\n          }\n\n          if ("flex" === rdom[ridx].parent().style("display") || "flex" === cmputl.dispbuff(rdom[ridx].parent())) {\n            break;\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * text component position\n     * \n     * @param (mofron.class.Dom) dom objedt\n     * @type private\n     */\n\n  }, {\n    key: "txtpos",\n    value: function txtpos(dom) {\n      try {\n        if (null !== dom.parent() && ("flex" === dom.parent().style("display") || "flex" === cmputl.dispbuff(dom.parent()))) {\n          this.mgnpos(dom);\n        } else if ("absolute" === dom.style("position") || "flex" === dom.style("position")) {\n          this.lftpos(dom);\n        } else {\n          dom.style({\n            \'text-align\': this.type()\n          });\n\n          if (null !== this.offset()) {\n            dom.style({\n              "position": "relative"\n            });\n\n            if ("right" !== this.type()) {\n              dom.style({\n                "left": this.offset()\n              });\n            } else {\n              dom.style({\n                "right": this.offset()\n              });\n            }\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set margin position\n     * \n     * @param (mofron.class.Dom) dom object\n     * @type private\n     */\n\n  }, {\n    key: "mgnpos",\n    value: function mgnpos(dom) {\n      try {\n        var off = this.offset();\n\n        if (\'center\' === this.type()) {\n          dom.style({\n            "margin-right": "auto",\n            "margin-left": "auto"\n          });\n\n          if (null !== off) {\n            dom.style({\n              "position": "relative",\n              "left": off\n            });\n          }\n        } else if (\'left\' === this.type()) {\n          dom.style({\n            "margin-right": "auto",\n            "margin-left": "0rem"\n          });\n\n          if (null !== off) {\n            dom.style({\n              "margin-left": off\n            });\n          }\n        } else {\n          dom.style({\n            "margin-right": "0rem",\n            "margin-left": "auto"\n          });\n\n          if (null !== off) {\n            dom.style({\n              "margin-right": off\n            });\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set left position\n     *\n     * @param (mofron.class.Dom) dom object\n     * @type private\n     */\n\n  }, {\n    key: "lftpos",\n    value: function lftpos(dom) {\n      try {\n        var off = this.offset();\n\n        if (\'center\' === this.type()) {\n          dom.style({\n            "left": "50%"\n          });\n\n          if (null === off || "%" !== comutl.sizetype(off)) {\n            dom.style({\n              "transform": "translateX(-50%)"\n            }, {\n              bpref: true\n            });\n          } else {\n            dom.style({\n              "transform": "translateX(" + comutl.sizesum("-50%", off) + ")"\n            }, {\n              bpref: true\n            });\n          }\n        } else if (\'left\' === this.type()) {\n          dom.style({\n            "left": null !== off ? off : "0rem"\n          });\n        } else if (\'right\' === this.type()) {\n          dom.style({\n            "right": null !== off ? off : "0rem"\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * position type setter/getter\n     * \n     * @param (string) set position type (\'center\',\'left\',\'right\')\n     *                 undefind: call as getter\n     * @return (string) position type\n     * @type parameter\n     */\n\n  }, {\n    key: "type",\n    value: function type(prm) {\n      try {\n        return this.confmng("type", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * position offset setter/getter\n     * \n     * @param (string(size)) position offset size\n     *                       undefined: call as getter\n     * @return (mixed) string(size): position offset size\n     *                 null: not set\n     * @type parameter\n     */\n\n  }, {\n    key: "offset",\n    value: function offset(prm) {\n      try {\n        return this.confmng("offset", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-hrzpos/index.js?')},"./node_modules/mofron-effect-position/index.js":
/*!******************************************************!*\
  !*** ./node_modules/mofron-effect-position/index.js ***!
  \******************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-position/index.js\n * @brief position effect for mofron\n *        it makes easy to move the component position by the animation.\n * @feature default animation speed is 300ms\n * @attention it may not work well if "position" was configured incorrectly.\n *            "position" is disabled if the target component was already set "position" style.\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize effect\n   *\n   * @param (mixed) string: directionconfig  parameter\n   *                        dict: effect config list\n   * @param (string(size)) value parameter\n   * @short dirction,value\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Position");\n\n      _this.shortForm("direction", "value");\n\n      _this.speed(300);\n      /* init config */\n\n\n      _this.confmng().add("position", {\n        type: "string",\n        select: ["absolute", "fixed", "inherit", "initial", "relative", "static", "sticky", "unset"],\n        init: "relative"\n      });\n\n      _this.confmng().add("direction", {\n        type: "string",\n        select: ["top", "left", "bottom", "right"],\n        init: "left"\n      });\n\n      _this.confmng().add("value", {\n        type: "size"\n      });\n\n      _this.beforeEvent(function (eff) {\n        try {\n          eff.component().style({\n            "position": eff.position()\n          }, {\n            passive: true\n          });\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * effect contents\n   * set end position\n   * \n   * @param (object) effect target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        var tp = {};\n        tp[this.direction()] = this.value();\n        cmp.style(tp);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * position type setter/getter\n     * value of "position" style\n     *\n     * @param (string) position type, the default is "relative"\n     *                 ["absolute"/"fixed"/"inherit"/"initial"/"relative"/"static"/"sticky"/"unset"]\n     * @return (string) position type\n     * @type parameter\n     */\n\n  }, {\n    key: "position",\n    value: function position(prm) {\n      try {\n        return this.confmng("position", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * direction type\n     *\n     * @param (string) direction type, the default is "left"\n     *                 ["top"/"left"/"bottom"/"right"]\n     * @return (string) direction type\n     * @type parameter\n     */\n\n  }, {\n    key: "direction",\n    value: function direction(prm) {\n      try {\n        return this.confmng("direction", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * position value\n     * component position is moved by this value size\n     * \n     * @param (string) begin position value, default is "0rem"\n     * @param (string) end position value, default is "0rem"\n     * @return (string) position value\n     * @type parameter\n     */\n\n  }, {\n    key: "value",\n    value: function value(prm) {\n      try {\n        return this.confmng("value", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-position/index.js?')},"./node_modules/mofron-effect-radius/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-radius/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-radius/index.js\n * @brief radius effect for mofron\n *        this effect makes the components of outside rounded style\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize radius effect\n   *\n   * @param (mixed) value parameter\n   *                key-value: effect config\n   * @short value\n   * @type private\n   */\n  function _class(p1) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Radius\');\n\n      _this.shortForm(\'value\');\n      /* init config */\n\n\n      _this.confmng().add("value", {\n        type: "size",\n        init: "0.5rem"\n      });\n\n      _this.confmng().add("position", {\n        list: true,\n        select: ["top-left", "top-right", "bottom-left", "bottom-right"]\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * radius size\n   *\n   * @param (string (size)) radius size\n   * @return (string (size)) radius size\n   * @type parameter\n   */\n\n\n  _createClass(_class, [{\n    key: "value",\n    value: function value(prm) {\n      try {\n        return this.confmng("value", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * radius target position\n     * each position will be targeted if nothing is set \n     * \n     * @param (mixed) array: position list\n     *                string: target position ("top-left","top-right","bottom-left","bottom-right")\n     * @return (array) position list\n     * @type parameter\n     */\n\n  }, {\n    key: "position",\n    value: function position(prm) {\n      try {\n        return this.confmng(\'position\', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * effect contents\n     * \n     * @param (component) target component\n     * @type private\n     */\n\n  }, {\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        var pos = this.position();\n        var val = this.value().toString();\n\n        if (0 === pos.length) {\n          cmp.style({\n            \'border-radius\': val\n          }, {\n            bpref: true\n          });\n        } else {\n          var set_sty = {};\n\n          for (var tidx in pos) {\n            set_sty[\'border-\' + pos[tidx] + \'-radius\'] = val;\n          }\n\n          cmp.style(set_sty, {\n            bpref: true\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-radius/index.js?')},"./node_modules/mofron-effect-shadow/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-shadow/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file shadow.js\n * @brief shadow effect for mofron\n *        this effect makes the component has a shadow.\n * @feature the size changes according to the value of the \'value\' parameter.\n *          the blur percentage changes according to the value of the \'blur\' parameter.\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize effect\n   *\n   * @param (mixed) value parameter\n   *                key-value: effect config\n   * @param color parameter\n   * @short value,color\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Shadow\');\n\n      _this.shortForm(\'value\', \'color\');\n      /* init config */\n\n\n      _this.confmng().add("value", {\n        type: "size",\n        init: "0.015rem"\n      });\n\n      _this.confmng().add("blur", {\n        type: "size",\n        init: "0rem"\n      });\n\n      _this.confmng().add(\'color\', {\n        type: "color",\n        init: [190, 190, 190]\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * shadow size\n   *\n   * @param (string (size)) shadow size (css value)\n   * @return (string (size)) shadow size (css value)\n   * @type parameter\n   */\n\n\n  _createClass(_class, [{\n    key: "value",\n    value: function value(prm) {\n      try {\n        return this.confmng("value", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * blur size value\n     * \n     * @param (string (size)) blur size value\n     * @return (string (size)) blur size value\n     * @type parameter\n     */\n\n  }, {\n    key: "blur",\n    value: function blur(prm) {\n      try {\n        return this.confmng("blur", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * shadow color\n     *\n     * @param (string (size)) shadow color (css value)\n     * @return (string (size)) shadow color (css value)\n     * @type parameter\n     */\n\n  }, {\n    key: "color",\n    value: function color(prm) {\n      try {\n        return this.confmng("color", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * effect contents\n     * \n     * @param (component) target componet\n     * @type private\n     */\n\n  }, {\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        var str_val = this.value().toString();\n        var sum_val = comutl.sizesum(str_val, comutl.sizesum(str_val, str_val));\n        var set_val = {\n          "box-shadow": sum_val + \' \' + sum_val + \' \' + this.blur().toString() + \' \' + \'0rem \' + this.color().toString()\n        };\n        cmp.style(set_val, {\n          bpref: true\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-shadow/index.js?')},"./node_modules/mofron-effect-synchei/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-effect-synchei/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-synchei/index.js\n * @brief synchronize height of target component and height of effect component\n *        this effect resizes height of a target component when the height of the target component changed.\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * constructor\n   * \n   * @param (mixed) string: targetComp parameter\n   *                key-value: effect config\n   * @param (string) offset parameter\n   * @short targetComp,offset\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n      /* init config */\n\n      _this.confmng().add(\'targetComp\', {\n        type: \'Component\'\n      });\n\n      _this.confmng().add(\'offset\', {\n        type: \'size\'\n      });\n\n      _this.name(\'SyncHei\');\n\n      _this.shortForm(\'targetComp\', \'offset\');\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * setter/getter for height listen target component\n   * it triggers this effect when height of target component was changed.\n   *\n   * @param (mofron.class.Component) target component\n   *                                 undefined: call as getter\n   * @return (mixed) mofron.class.Component: target component\n   *                 null: not set\n   * @type parameter\n   */\n\n\n  _createClass(_class, [{\n    key: "targetComp",\n    value: function targetComp(prm) {\n      try {\n        var ret = this.confmng(\'targetComp\', prm);\n\n        if (undefined !== prm) {\n          var syn_fnc = function syn_fnc(p1, p2, sync) {\n            try {\n              sync.execute();\n            } catch (e) {\n              console.error(e.stack);\n              throw e;\n            }\n          };\n\n          prm.styleDom().style().listener(\'height\', syn_fnc, this);\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * offset value setter/getter\n     * this value is used for height adjustment\n     *\n     * @param (string(size)) offset value (default is \'0rem\')\n     *                       undefined: call as getter\n     * @return (string) offset value\n     * @type parameter\n     */\n\n  }, {\n    key: "offset",\n    value: function offset(prm) {\n      try {\n        return this.confmng(\'offset\', prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * synchronize height size\n     *\n     * @type private\n     */\n\n  }, {\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        if (null === this.targetComp()) {\n          this.targetComp(this.component().parent());\n        }\n\n        cmp.height(comutl.sizesum(this.targetComp().height(), this.offset()));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-synchei/index.js?')},"./node_modules/mofron-effect-syncwin/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-effect-syncwin/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-syncwin/index.js\n * @brief synchronize component with window\n *        target component size is changed even if the window size is changed.\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize effect\n   * \n   * @param (mixed) valid config parameter\n   *                dict: effect config list\n   * @param (mixed) offset config parameter\n   * @short valid,offset\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'SyncWin\');\n\n      _this.shortForm(\'valid\', \'offset\');\n      /* init config */\n\n\n      _this.confmng().add("x_valid", {\n        type: "boolean",\n        init: true\n      });\n\n      _this.confmng().add("y_valid", {\n        type: "boolean",\n        init: true\n      });\n\n      _this.confmng().add("x_offset", {\n        type: "size"\n      });\n\n      _this.confmng().add("y_offset", {\n        type: "size"\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * enable synchronize window size\n   * \n   * @param (component) effect target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(tgt) {\n      try {\n        var off = this.offset();\n        off[0] = null === off[0] ? undefined : comutl.getsize(off[0]).toPixel() + \'px\';\n        off[1] = null === off[1] ? undefined : comutl.getsize(off[1]).toPixel() + \'px\';\n\n        if (true === this.valid()[0]) {\n          /* set horizon size */\n          try {\n            tgt.width(comutl.sizesum(window.innerWidth + \'px\', off[0]));\n          } catch (e) {\n            tgt.width(window.innerWidth + \'px\');\n          }\n        }\n\n        if (true === this.valid()[1]) {\n          /* set vertical size */\n          try {\n            tgt.height(comutl.sizesum(window.innerHeight + \'px\', off[1]));\n          } catch (e) {\n            tgt.height(window.innerHeight + \'px\');\n          }\n        }\n\n        if (false === this.isInited()) {\n          var fnc = function fnc(eff) {\n            try {\n              eff.execute();\n            } catch (e) {\n              console.error(e.stack);\n              throw e;\n            }\n          };\n\n          mofron.window.resizeEvent(fnc, this);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set x,y valid flag\n     * \n     * @param (boolean) valid flag for horizon\n     * @param (boolean) valid flag for vertical\n     * @return (array) [x-flag, y-flag ]\n     * @type pararmeter\n     */\n\n  }, {\n    key: "valid",\n    value: function valid(x, y) {\n      try {\n        if (undefined === x) {\n          /* getter */\n          return [this.x_valid(), this.y_valid()];\n        }\n        /* setter */\n\n\n        this.x_valid(x);\n        this.y_valid(y);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * horizonal valid flag setter/getter\n     * \n     * @param (boolean) true: enabled horizonal sync [default]\n     *                  false: disabled horizonal sync\n     *                  undefined: call as getter\n     * @return (boolean) horizonal valid flag\n     * @type parameter\n     */\n\n  }, {\n    key: "x_valid",\n    value: function x_valid(prm) {\n      try {\n        return this.confmng("x_valid", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * vertical valid flag setter/getter\n     * \n     * @param (boolean) true: enabled vertical sync [default]\n     *                  false: disabled vertical sync\n     *                  undefined: call as getter\n     * @return (boolean) vertival valid flag\n     * @type parameter\n     */\n\n  }, {\n    key: "y_valid",\n    value: function y_valid(prm) {\n      try {\n        return this.confmng("y_valid", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * setter/getter offset size\n     * \n     * @param (string (size)) horizonal offset size\n     * @param (string (size)) vertical offset size\n     * @return (array) [horizon offset size, vertical offset size]\n     * @type parameter\n     */\n\n  }, {\n    key: "offset",\n    value: function offset(x, y) {\n      try {\n        if (undefined === x) {\n          /* getter */\n          return [this.x_offset(), this.y_offset()];\n        }\n        /* setter */\n\n\n        this.x_offset(x);\n        this.y_offset(y);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * horizonal offset size setter/getter\n     * \n     * @param (string(size)) horizonal offset size\n     * @return (string(size)) horizonal offset size\n     * @type parameter\n     */\n\n  }, {\n    key: "x_offset",\n    value: function x_offset(prm) {\n      try {\n        return this.confmng("x_offset", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * vertical offset size setter/getter\n     * \n     * @param (string(size)) vertical offset size\n     * @return (string(size)) vertical offset size\n     * @type parameter\n     */\n\n  }, {\n    key: "y_offset",\n    value: function y_offset(prm) {\n      try {\n        return this.confmng("y_offset", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-syncwin/index.js?')},"./node_modules/mofron-effect-synwwid/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-effect-synwwid/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-synwwid/index.js\n * @brief effect for synchronize component width with window\n * @license MIT\n */\nvar Syncwin = __webpack_require__(/*! mofron-effect-syncwin */ "./node_modules/mofron-effect-syncwin/index.js");\n\nmodule.exports = /*#__PURE__*/function (_Syncwin) {\n  _inherits(_class, _Syncwin);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize effect\n   * \n   * @param (mixed) offset parameter\n   *                effect config\n   * @short x_offset\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Synwwid\');\n\n      _this.shortForm(\'x_offset\');\n\n      _this.valid(true, false);\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  return _class;\n}(Syncwin);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-synwwid/index.js?')},"./node_modules/mofron-effect-vrtpos/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron-effect-vrtpos/index.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-effect-vrtpos/index.js\n * @brief vertical position effect for mofron component\n *        the component is positioned specified parameter that is \'center\' or \'top\' and \'bottom\'.\n * @license MIT\n */\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Effect) {\n  _inherits(_class, _mofron$class$Effect);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize vertical position effect\n   *\n   * @param (mixed) type config parameter\n   *                key-value: effect config list\n   * @param offset config parameter\n   * @short type,offset\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("VrtPos");\n\n      _this.shortForm("type", "offset");\n      /* init config */\n\n\n      _this.confmng().add("type", {\n        type: "string",\n        select: ["top", "center", "bottom"],\n        init: "center"\n      });\n\n      _this.confmng().add("offset", {\n        type: "size"\n      });\n      /* set config */\n\n\n      _this.innerTgt(false);\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * effet contents\n   * \n   * @param (mofron.class.Component) effect target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(cmp) {\n      try {\n        var rdom = cmp.rootDom();\n\n        for (var ridx in rdom) {\n          if (true === comutl.isinc(cmp, "Text")) {\n            this.txtpos(rdom[ridx]);\n            return;\n          } else if ("absolute" === rdom[ridx].style("position") || "relative" === rdom[ridx].style("position") || "fixed" === rdom[ridx].style("position")) {\n            this.toppos(rdom[ridx]);\n          } else if ("flex" === rdom[ridx].parent().style("display") || "flex" === cmputl.dispbuff(rdom[ridx])) {\n            this.mgnpos(rdom[ridx]);\n          } else {\n            rdom[ridx].style({\n              "position": "relative"\n            }, {\n              passive: true\n            });\n            this.toppos(rdom[ridx]);\n          }\n\n          if ("flex" !== rdom[ridx].parent().style("display")) {\n            break;\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set text component position\n     * \n     * @param (mofron.class.Dom) dom object\n     * @type private\n     */\n\n  }, {\n    key: "txtpos",\n    value: function txtpos(dom) {\n      try {\n        var off = this.offset();\n        var pnt = dom.parent();\n\n        if (null !== pnt) {\n          var pnt_disp = "none" === pnt.style("display") ? cmputl.dispbuff(pnt) : pnt.style("display");\n\n          if ("flex" === pnt_disp || \'grid\' === pnt_disp) {\n            if ("center" === this.type()) {\n              pnt.style({\n                "align-items": "center"\n              });\n            } else if ("bottom" === this.type()) {\n              pnt.style({\n                "align-items": "flex-end"\n              });\n            }\n\n            if (null !== off) {\n              dom.style({\n                "position": "relative"\n              }, {\n                passive: true\n              });\n              dom.style({\n                "top": off\n              });\n            }\n          }\n        } else {\n          dom.style({\n            "position": "relative"\n          }, {\n            passive: true\n          });\n          this.toppos(dom);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set position by top value\n     * \n     * @param (mofron.class.Dom) effect target component\n     * @type private\n     */\n\n  }, {\n    key: "toppos",\n    value: function toppos(dom) {\n      try {\n        var off = this.offset();\n\n        if ("center" === this.type()) {\n          dom.style({\n            "top": "50%"\n          });\n          dom.style({\n            "transform": "translateY(-50%)"\n          }, {\n            bpref: true\n          });\n\n          if (null !== off) {\n            dom.style({\n              "margin-top": off\n            });\n          }\n        } else if ("top" === this.type()) {\n          dom.style({\n            "top": null !== off ? off : "0rem"\n          });\n        } else {\n          dom.style({\n            "bottom": null !== off ? off : "0rem"\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set position by margin value\n     * \n     * @param (mofron.class.Dom) dom object\n     * @type private\n     */\n\n  }, {\n    key: "mgnpos",\n    value: function mgnpos(dom) {\n      try {\n        var off = this.offset();\n\n        if ("center" === this.type()) {\n          dom.style({\n            "margin-top": "auto",\n            "margin-bottom": "auto"\n          });\n\n          if (null !== off) {\n            dom.style({\n              "position": "relative"\n            }, {\n              passive: true\n            });\n            dom.style({\n              "top": off\n            });\n          }\n        } else if ("top" === this.type()) {\n          dom.style({\n            "margin-top": null !== off ? off : "0rem",\n            "margin-bottom": "auto"\n          });\n        } else {\n          dom.style({\n            "margin-top": "auto",\n            "margin-bottom": null !== off ? off : "0rem"\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * position type setter/getter\n     *\n     * @param (string) position type (center,top,bottom)\n     *                 undefined: call as getter\n     * @return (string) position type\n     * @type parameter\n     */\n\n  }, {\n    key: "type",\n    value: function type(prm) {\n      try {\n        return this.confmng("type", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * offset size setter/getter\n     *\n     * @param (string(size)) offset size\n     *                       undefined: call as getter\n     * @return (mofron.class.Size) offset size\n     * @type parameter\n     */\n\n  }, {\n    key: "offset",\n    value: function offset(prm) {\n      try {\n        return this.confmng("offset", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Effect);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-effect-vrtpos/index.js?')},"./node_modules/mofron-event-click/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-event-click/index.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-event-click/index.js\n * @brief click event for mofron component\n *        it executes an event function when the component is clicked\n * ## event function parameter\n *  - component: event target component object\n *  - object: MouseEvent object of addEventListener\n *  - mixed: user specified parameter\n * @license MIT\n */\nvar Common = __webpack_require__(/*! mofron-event-common */ "./node_modules/mofron-event-common/index.js");\n\nmodule.exports = /*#__PURE__*/function (_Common) {\n  _inherits(_class, _Common);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize click event\n   * \n   * @param (mixed) listener parameter\n   *                key-value: event config\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Click");\n\n      _this.shortForm("listener");\n      /* init config */\n\n\n      _this.confmng().add("pointer", {\n        type: "boolean",\n        init: true\n      });\n\n      _this.type("click");\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * add click event to target component.\n   * \n   * @param (component) event target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(tgt) {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "contents", this).call(this, tgt);\n\n        if (true === this.pointer()) {\n          this.component().style({\n            \'cursor\': \'pointer\'\n          }, {\n            passive: true\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * mouse cursor style\n     *\n     * @param (boolean) true: mouse-in cursor is pointer [default]\n     *                  false: mouse-in coursor is default\n     * @return (boolean) mouse-in cursor style\n     * @type parameter\n     */\n\n  }, {\n    key: "pointer",\n    value: function pointer(flg) {\n      try {\n        return this.confmng("pointer", flg);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Common);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-click/index.js?')},"./node_modules/mofron-event-clkfocus/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-event-clkfocus/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-event-clkfocus/index.js\n * @brief click focus event for mofron\n * ## event function parameter\n *  - component: event target component object\n *  - boolean: focus flag\n *  - mixed: user specified parameter\n * @feature this event notify when enable focus by clicking component and disable focus by clicking the other than that.\n * @attention not supported focus event by tab key\n * @license MIT\n */\nvar Click = __webpack_require__(/*! mofron-event-click */ "./node_modules/mofron-event-click/index.js");\n\nmodule.exports = /*#__PURE__*/function (_Click) {\n  _inherits(_class, _Click);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize event\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: event config\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'ClkFocus\');\n      /* init config */\n\n\n      _this.confmng().add("clickFlag", {\n        type: "boolean",\n        init: false\n      });\n\n      _this.confmng().add("status", {\n        type: "boolean",\n        init: false\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * event contents for target component\n   * \n   * @param (mofron.class.Dom) target dom object\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(tgt_dom) {\n      try {\n        if (true === this.pointer()) {\n          tgt_dom.component().style({\n            "cursor": "pointer"\n          });\n        }\n\n        var evt = this;\n        tgt_dom.getRawDom().addEventListener(\'click\', function () {\n          try {\n            evt.clickFlag(true);\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        }, false);\n\n        var win_clk = function win_clk() {\n          try {\n            if (true === evt.status() && false === evt.clickFlag()) {\n              evt.execListener(false);\n              evt.status(false);\n            } else if (false === evt.status() && true === evt.clickFlag()) {\n              evt.execListener(true);\n              evt.status(true);\n            }\n\n            evt.clickFlag(false);\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n\n        mofron.window.event(new Click(win_clk));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * flag for target clicked\n     *\n     * @param (boolean) click flag\n     * @return (boolean) click flag\n     * @type private\n     */\n\n  }, {\n    key: "clickFlag",\n    value: function clickFlag(prm) {\n      try {\n        return this.confmng("clickFlag", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * focus status flag setter/getter\n     *\n     * @param (boolean) focus status flag\n     *                  undefined: call as getter\n     * @return (boolean) focus status flag\n     * @type function\n     */\n\n  }, {\n    key: "status",\n    value: function status(prm) {\n      try {\n        return this.confmng("status", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Click);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-clkfocus/index.js?')},"./node_modules/mofron-event-common/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron-event-common/index.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-event-common/index.js\n * @brief common event for mofron\n *        set addEventListener of target object\n *        it is possible to use addEventListener() for general by setting the parameter of the type method.\n * ## event function parameter\n *  - component: event target component object\n *  - object: event object of addEventListener\n *  - mixed: user specified parameter\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Event) {\n  _inherits(_class, _mofron$class$Event);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize common event\n   * \n   * @param (mixed) short-form parameter\n   *                key-value: event config\n   * @short listener,type\n   * @type private\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Common");\n\n      _this.shortForm("listener", "type");\n      /* init config */\n\n\n      _this.confmng().add("type", {\n        type: "string"\n      });\n      /* set config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * event type\n   * \n   * @param (string) event type\n   * @return (string) event type\n   * @type parameter\n   */\n\n\n  _createClass(_class, [{\n    key: "type",\n    value: function type(prm) {\n      try {\n        return this.confmng("type", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * event contents\n     * \n     * @param (mofron.class.Dom) event target dom\n     * @type private\n     */\n\n  }, {\n    key: "contents",\n    value: function contents(tgt_dom) {\n      try {\n        var evt_obj = this;\n        tgt_dom.getRawDom().addEventListener(this.type(), function (e) {\n          try {\n            evt_obj.execListener(e);\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        }, false);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Event);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-common/index.js?')},"./node_modules/mofron-event-link/index.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron-event-link/index.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-event-link/index.js\n * @brief enable link to target component\n * ## event function parameter\n *  - component: event target component object\n *  - event: "click" event object by addEventListener\n *  - mixed: user specified parameter\n * @license MIT\n */\nvar Click = __webpack_require__(/*! mofron-event-click */ "./node_modules/mofron-event-click/index.js");\n\nmodule.exports = /*#__PURE__*/function (_Click) {\n  _inherits(_class, _Click);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize event\n   * \n   * @param (mixed) url parameter\n   *                key-value: event config\n   * @param (boolean) newtab parameter\n   * @short url,newtab\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Link");\n\n      _this.shortForm("url", "newtab");\n\n      _this.confmng().add("url", {\n        type: "string",\n        init: "./"\n      });\n\n      _this.confmng().add("newtab", {\n        type: "boolean",\n        init: false\n      });\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * event contents\n   * set url jump event to click handler\n   * \n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(tgt_dom) {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "contents", this).call(this, tgt_dom);\n\n        var link = this;\n        this.listener(function () {\n          try {\n            if (true === link.newtab()) {\n              window.open(link.url(), \'_blank\');\n            } else {\n              window.location.href = link.url();\n            }\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        }, this);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * jump url\n     *\n     * @param (string) jump url (default is \'./\')\n     * @type parameter\n     */\n\n  }, {\n    key: "url",\n    value: function url(prm) {\n      try {\n        return this.confmng("url", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * newtab flag\n     * \n     * @param (boolean) true: jump to url by newtab (default)\n     *                  false: jump to url by current tab\n     * @type parameter\n     */\n\n  }, {\n    key: "newtab",\n    value: function newtab(prm) {\n      try {\n        return this.confmng("newtab", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Click);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-event-link/index.js?')},"./node_modules/mofron-layout-grid/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron-layout-grid/index.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-layout-grid/index.js\n * @brief grid layout for mofron\n *        it makes component size to a specified size, and positions by horizontal.\n *        when it positioned at the horizontal end, it turns back on the left side and positions under its.\n * @attention please specify either the ratio parameter or the width parameter\n *            it gives priority to ratio parameter if users specified both\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Layout) {\n  _inherits(_class, _mofron$class$Layout);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize layout\n   * \n   * @param (mixed) ratio parameter\n   *                key-value: layout config\n   * @short ratio\n   * @type private\n   */\n  function _class(p1) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Grid");\n\n      _this.shortForm("ratio");\n      /* init config */\n\n\n      _this.confmng().add("ratio", {\n        type: "array",\n        init: [25, 25, 25, 25]\n      });\n\n      _this.confmng().add("width", {\n        type: "array"\n      });\n\n      _this.confmng().add("height", {\n        type: "size"\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * layout contents\n   * \n   * @param (number) child index\n   * @param (component) layout target component\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(idx, tgt) {\n      try {\n        var wid = this.width();\n\n        if (0 === idx) {\n          this.component().style({\n            "display": "flex",\n            "flex-wrap": "wrap"\n          });\n\n          if (null !== wid) {\n            var cmp_wid = null;\n\n            for (var widx in wid) {\n              cmp_wid = comutl.sizesum(cmp_wid, wid[widx]);\n            }\n\n            this.component().width(cmp_wid);\n          }\n        }\n        /* set width */\n\n\n        if (null !== this.width()) {\n          tgt.width(this.width()[idx % this.width().length]);\n        } else {\n          tgt.width(this.ratio()[idx % this.ratio().length] + \'%\');\n        }\n        /* set height */\n\n\n        if (null !== this.height()) {\n          tgt.height(this.height());\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * units width ratio of grid\n     * \n     * @param (array) units width ratio [number,number,..]\n     * @return (array) units width ratio\n     * @attention parameter sum should be 100\n     * @type parameter\n     */\n\n  }, {\n    key: "ratio",\n    value: function ratio(prm) {\n      try {\n        var ret = this.confmng("ratio", prm);\n\n        if (undefined !== prm) {\n          for (var pidx in prm) {\n            if ("number" !== typeof prm[pidx]) {\n              throw new Error("invalid parameter");\n            }\n          }\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * width size for grid target\n     * \n     * @param (array) width size for grid target [string,string,..]\n     * @return (array) width size for grid target\n     * @type parameter\n     */\n\n  }, {\n    key: "width",\n    value: function width(prm) {\n      try {\n        var ret = this.confmng("size", prm);\n\n        if (undefined !== prm) {\n          for (var pidx in prm) {\n            comutl.getsize(prm[pidx]);\n          }\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * height size for grid target\n     *\n     * @param (string (size)) height size for grid target\n     * @return (string (size)) height size for grid target\n     * @type parameter\n     */\n\n  }, {\n    key: "height",\n    value: function height(prm) {\n      try {\n        return this.confmng("height", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Layout);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-layout-grid/index.js?')},"./node_modules/mofron-layout-horizon/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron-layout-horizon/index.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-layout-horizon/index.js\n * @brief horizon layout for mofron\n *        target component of children is positioned horizontally.\n * @license MIT\n */\nmodule.exports = /*#__PURE__*/function (_mofron$class$Layout) {\n  _inherits(_class, _mofron$class$Layout);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize layout\n   * \n   * @type private\n   */\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Horizon\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * set horizon style\n   *\n   * @type private\n   */\n\n\n  _createClass(_class, [{\n    key: "execute",\n    value: function execute() {\n      try {\n        this.component().style(_defineProperty({\n          \'display\': \'-webkit-flex\'\n        }, "display", \'flex\'));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Layout);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-layout-horizon/index.js?')},"./node_modules/mofron-layout-relative/index.js":
/*!******************************************************!*\
  !*** ./node_modules/mofron-layout-relative/index.js ***!
  \******************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file mofron-layout-relative/index.js\n * @brief relative layout of mofron\n * @feature components are placed offset by \'relative\' style value\n * @license MIT\n */\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Layout) {\n  _inherits(_class, _mofron$class$Layout);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize layout\n   *\n   * @param (mixed) type config parameter\n   *                key-value: layout config list\n   * @param (string(size)) value config parameter\n   * @short type,value\n   * @type private\n   */\n  function _class(p1, p2) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Relative");\n\n      _this.shortForm("type", "value");\n      /* init config */\n\n\n      _this.confmng().add("type", {\n        type: "string",\n        select: ["top", "right", "bottom", "left"],\n        init: "top"\n      });\n\n      _this.confmng().add("value", {\n        type: "size",\n        init: "0rem"\n      });\n\n      _this.confmng().add("multiple", {\n        type: "boolean",\n        init: true\n      });\n      /* set config */\n\n\n      if (0 < arguments.length) {\n        _this.config(p1, p2);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * layout contents\n   * \n   * @param (number) component index\n   * @param (component) target component\n   * @type private \n   */\n\n\n  _createClass(_class, [{\n    key: "contents",\n    value: function contents(idx, tgt) {\n      try {\n        var setmgn = {};\n        setmgn[\'position\'] = \'relative\';\n        var val = comutl.getsize(this.value());\n\n        if (true === this.multiple()) {\n          var ival = comutl.flo2int(val.value());\n\n          if (0 === ival[1]) {\n            setmgn[this.type()] = ival[0] * (idx + 1) + val.type();\n          } else {\n            setmgn[this.type()] = ival[0] * (idx + 1) / ival[1] + val.type();\n          }\n        } else {\n          setmgn[this.type()] = this.value();\n        }\n\n        tgt.rootDom()[0].style(setmgn); //cmputl.rstyle(this.component(), setmgn);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * direction type\n     * \n     * @param (string) direction type ["top"/"right"/"bottom"/"left"]\n     * @return (string) direction type\n     * @type parameter\n     */\n\n  }, {\n    key: "type",\n    value: function type(prm) {\n      try {\n        return this.confmng("type", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * offset value\n     *\n     * @param (string(size)) offset value\n     * @return (string(size)) offset value\n     * @type parameter\n     */\n\n  }, {\n    key: "offset",\n    value: function offset(prm) {\n      try {\n        return this.value(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * same as \'offset\'\n     *\n     * @param (string) same as \'offset\' parameter\n     * @return (string) same as \'offset\' return\n     * @type parameter\n     */\n\n  }, {\n    key: "value",\n    value: function value(prm) {\n      try {\n        return this.confmng("value", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * multiples value flag\n     *\n     * @param (boolean) true: offset value is multiples values to the component index\n     *                  false: offset value not multiples\n     * @return (boolean) multiple flag\n     * @type parameter\n     */\n\n  }, {\n    key: "multiple",\n    value: function multiple(prm) {\n      try {\n        return this.confmng("multiple", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Layout);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron-layout-relative/index.js?')},"./node_modules/mofron/index.js":
/*!**************************************!*\
  !*** ./node_modules/mofron/index.js ***!
  \**************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('__webpack_require__(/*! expose-loader?mofron!./src/core/namesp.js */ "./node_modules/expose-loader/index.js?mofron!./node_modules/mofron/src/core/namesp.js-exposed");\n/* util functions */\n\n\n__webpack_require__(/*! ./src/util/common.js */ "./node_modules/mofron/src/util/common.js");\n\n__webpack_require__(/*! ./src/util/component.js */ "./node_modules/mofron/src/util/component.js");\n\n__webpack_require__(/*! ./src/util/effect.js */ "./node_modules/mofron/src/util/effect.js");\n\nmofron["class"].ConfArg = __webpack_require__(/*! ./src/type/ConfArg.js */ "./node_modules/mofron/src/type/ConfArg.js");\nmofron["class"].PullConf = __webpack_require__(/*! ./src/type/PullConf.js */ "./node_modules/mofron/src/type/PullConf.js");\nmofron["class"].EventFrame = __webpack_require__(/*! ./src/type/EventFrame.js */ "./node_modules/mofron/src/type/EventFrame.js");\nmofron["class"].Dom = __webpack_require__(/*! ./src/core/dom/Dom.js */ "./node_modules/mofron/src/core/dom/Dom.js");\nmofron["class"].Component = __webpack_require__(/*! ./src/tag/Component.js */ "./node_modules/mofron/src/tag/Component.js");\nmofron["class"].Layout = __webpack_require__(/*! ./src/tag/Layout.js */ "./node_modules/mofron/src/tag/Layout.js");\nmofron["class"].Effect = __webpack_require__(/*! ./src/tag/Effect.js */ "./node_modules/mofron/src/tag/Effect.js");\nmofron["class"].Event = __webpack_require__(/*! ./src/tag/Event.js */ "./node_modules/mofron/src/tag/Event.js");\nmofron["class"].Color = __webpack_require__(/*! ./src/type/Color.js */ "./node_modules/mofron/src/type/Color.js");\nmofron["class"].Size = __webpack_require__(/*! ./src/type/size/Size.js */ "./node_modules/mofron/src/type/size/Size.js");\nmofron["class"].Pixel = __webpack_require__(/*! ./src/type/size/Pixel.js */ "./node_modules/mofron/src/type/size/Pixel.js");\nmofron["class"].Rem = __webpack_require__(/*! ./src/type/size/Rem.js */ "./node_modules/mofron/src/type/size/Rem.js");\n\nvar Window = __webpack_require__(/*! ./src/core/Window.js */ "./node_modules/mofron/src/core/Window.js");\n\nmofron.window = new Window();\n\nvar Document = __webpack_require__(/*! ./src/core/Document.js */ "./node_modules/mofron/src/core/Document.js");\n\nmofron.document = new Document();\nmodule.exports = mofron;\n\n//# sourceURL=webpack:///./node_modules/mofron/index.js?')},"./node_modules/mofron/src/core/Base.js":
/*!**********************************************!*\
  !*** ./node_modules/mofron/src/core/Base.js ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @file  Base.js\n * @brief basement class of mofron\n * @author simpart\n */\nvar comutl = mofron.util.common;\n\nvar ConfManager = __webpack_require__(/*! ./ConfManager.js */ "./node_modules/mofron/src/core/ConfManager.js");\n\nvar genid = function genid() {\n  try {\n    var ret_id = \'_\' + new Date().getTime() + \'-\';\n    var loop = 0;\n    var val = 0;\n\n    for (loop = 0; loop < 8; loop++) {\n      val = Math.random() * 16 | 0;\n      ret_id += (loop == 12 ? 4 : loop == 16 ? val & 3 | 8 : val).toString(16);\n    }\n\n    return ret_id;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  function _class() {\n    _classCallCheck(this, _class);\n\n    try {\n      this.m_confmng = new ConfManager();\n      this.confmng().add("name", {\n        list: true,\n        type: "string",\n        target: "private"\n      });\n      this.confmng().add("id", {\n        type: "string",\n        target: "private",\n        init: genid()\n      });\n      this.confmng().add("objkey", {\n        type: "string",\n        target: "private"\n      });\n      this.confmng().add("data", {\n        type: "key-value",\n        target: "private"\n      });\n      this.confmng().add("shortForm", {\n        type: "array",\n        target: "private",\n        init: []\n      });\n      this.name("Base");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  _createClass(_class, [{\n    key: "confmng",\n    value: function confmng(key, val, val2) {\n      try {\n        if (undefined === key) {\n          return this.m_confmng;\n        }\n\n        return this.m_confmng.conf(key, val, val2);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * component name setter / getter\n     *\n     * @param (string) component name\n     * @return (string) component name\n     * @note parameter syntax\n     */\n\n  }, {\n    key: "name",\n    value: function name(prm) {\n      try {\n        var ret = this.confmng("name", prm);\n        return undefined !== ret ? ret[ret.length - 1] : ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "id",\n    value: function id() {\n      try {\n        return this.confmng().get("id");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "objkey",\n    value: function objkey(key) {\n      try {\n        if (undefined !== key) {\n          mofron.objkey[key] = this;\n        }\n\n        return this.confmng("objkey", key);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "data",\n    value: function data(key, val) {\n      try {\n        if ("string" !== typeof key) {\n          throw new Error("invalid parameter");\n        }\n\n        var dat = this.confmng().get("data");\n\n        if (undefined === val) {\n          /* getter */\n          return undefined === dat[key] ? null : dat[key];\n        }\n        /* setter */\n\n\n        dat[key] = val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "shortForm",\n    value: function shortForm() {\n      try {\n        if (0 === arguments.length) {\n          return this.confmng().get("shortForm");\n        }\n\n        var val = [];\n\n        for (var aidx in arguments) {\n          val.push(arguments[aidx]);\n        }\n\n        this.confmng("shortForm", val);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /*** config method ***/\n\n  }, {\n    key: "config",\n    value: function config() {\n      try {\n        /* get argument */\n        if (0 === arguments.length) {\n          /* getter */\n          return this.confmng().get();\n        }\n\n        var arg = new mofron["class"].ConfArg();\n        arg.param(arguments);\n        /* setter */\n\n        if (1 < arg.param().length || !("object" === _typeof(arguments[0]) && false === Array.isArray(arguments[0]) && false === comutl.isinc(arguments[0], "Base"))) {\n          /* short form */\n          arg.exec(this, this.shortForm());\n        } else {\n          /* config */\n          for (var cf_idx in arguments[0]) {\n            if ("function" !== typeof this[cf_idx]) {\n              console.warn("invalid function: " + cf_idx);\n              continue;\n            }\n\n            if (true !== comutl.isinc(arguments[0][cf_idx], "ConfArg")) {\n              this[cf_idx](arguments[0][cf_idx]);\n            } else {\n              arguments[0][cf_idx].exec(this, cf_idx);\n            }\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}();\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Base.js?')},"./node_modules/mofron/src/core/ConfManager.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron/src/core/ConfManager.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @file ConfManager.js\n * @brief config manager for mofron modules. it suply accessor functions to object.\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function () {\n  function _class() {\n    _classCallCheck(this, _class);\n\n    try {\n      this.m_conf = {};\n      this.m_opt = {};\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  _createClass(_class, [{\n    key: "conf",\n    value: function conf(key, val, val2) {\n      try {\n        if ("string" !== typeof key) {\n          throw new Error("invalid parameter");\n        }\n\n        return undefined === val ? this.get(key) : this.set(key, val, val2);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "add",\n    value: function add(key, opt) {\n      try {\n        if ("object" !== _typeof(opt) || true === Array.isArray(opt) || true === comutl.isinc(opt, "Base")) {\n          throw new Error("invalid parameter");\n        }\n\n        this.m_opt[key] = opt;\n\n        if ("key-value" === opt.type) {\n          this.m_conf[key] = {};\n          return;\n        } else if (true === opt.list) {\n          this.m_conf[key] = [];\n          return;\n        }\n\n        if (undefined !== opt.init) {\n          this.set(key, opt.init);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "get",\n    value: function get(key) {\n      try {\n        if (undefined === key) {\n          /* get all config */\n          return this.m_conf;\n        } else if ("string" !== typeof key) {\n          throw new Error("invalid parameter");\n        }\n        /* return config */\n\n\n        return undefined !== this.m_conf[key] ? this.m_conf[key] : null;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "chkValue",\n    value: function chkValue(key, val, val2) {\n      try {\n        var opt = this.m_opt[key];\n\n        if (undefined === opt || undefined === opt.type) {\n          throw new Error("could not find :" + key);\n        }\n\n        if ("color" === opt.type) {\n          var clr = comutl.getcolor(val);\n          return null === clr ? clr : clr.toString();\n        } else if ("size" === opt.type) {\n          comutl.getsize(val);\n          return val;\n        } else if ("event" === opt.type) {\n          if ("function" !== typeof val) {\n            throw new Error(\'invalid parameter\');\n          }\n\n          return [val, val2];\n        } else if ("array" === opt.type) {\n          if (false === Array.isArray(val)) {\n            throw new Error(\'invalid parameter\');\n          }\n        } else if ("key-value" === opt.type) {\n          if ("object" !== _typeof(val) || true === Array.isArray(val) || true === comutl.isinc(val, "Base")) {\n            throw new Error(\'invalid parameter\');\n          }\n        } else if (true === comutl.isinc(val, \'Base\')) {\n          if (false === comutl.isinc(val, opt.type)) {\n            throw new Error(\'invalid parameter\');\n          }\n        } else if (opt.type !== _typeof(val)) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        return val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "set",\n    value: function set(key, val, val2) {\n      try {\n        if ("string" !== typeof key || undefined === this.m_opt[key]) {\n          throw new Error("invalid parameter");\n        }\n\n        if (true === this.m_opt[key].list && true === Array.isArray(val) && "array" !== this.m_opt[key].type) {\n          for (var vidx in val) {\n            this.set(key, val[vidx]);\n          }\n\n          return;\n        }\n\n        var set_val = this.chkValue(key, val, val2);\n\n        if (true === this.m_opt[key].list) {\n          this.m_conf[key].push(set_val);\n        } else if ("key-value" === this.m_opt[key].type) {\n          for (var _vidx in val) {\n            this.m_conf[key][_vidx] = val[_vidx];\n          }\n        } else {\n          if (true === Array.isArray(this.m_opt[key].select)) {\n            var exs = false;\n\n            for (var sidx in this.m_opt[key].select) {\n              if (set_val === this.m_opt[key].select[sidx]) {\n                exs = true;\n                break;\n              }\n            }\n\n            if (false === exs) {\n              throw new Error("invald parameter");\n            }\n          }\n\n          this.m_conf[key] = set_val;\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "delete",\n    value: function _delete(key) {\n      try {\n        if ("string" !== typeof key) {\n          throw new Error("invalid parameter");\n        }\n\n        delete this.m_conf[key];\n        this.add(key, this.m_opt[key]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}();\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/ConfManager.js?')},"./node_modules/mofron/src/core/Document.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/core/Document.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Window.js\n * @brief mofron window class\n */\nvar Base = __webpack_require__(/*! ./Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nvar comutl = __webpack_require__(/*! ./../util/common.js */ "./node_modules/mofron/src/util/common.js");\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Document\');\n\n      _this.confmng().add("event", {\n        type: "Event",\n        list: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "getRawDom",\n    value: function getRawDom() {\n      return document;\n    }\n  }, {\n    key: "event",\n    value: function event(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return this.confmng("event");\n        }\n        /* setter */\n\n\n        this.confmng("event", prm); //prm.component(this);\n\n        prm.contents(this);\n        prm.isInited(true);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Document.js?')},"./node_modules/mofron/src/core/ModConf.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron/src/core/ModConf.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file ModConf.js\n * @brief module config interface for mofron component\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ./Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  function _class(po) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, po);\n\n      _this.name(\'ModConf\');\n      /* init config */\n\n\n      _this.confmng().add("component", {\n        type: "Component"\n      });\n\n      _this.confmng().add("tag", {\n        type: "string"\n      });\n\n      _this.confmng().add("isInited", {\n        type: "boolean",\n        init: false\n      });\n\n      _this.confmng().add("suspend", {\n        type: "boolean",\n        init: false\n      });\n\n      _this.confmng().add("innerTgt", {\n        type: "boolean",\n        init: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "component",\n    value: function component(prm) {\n      try {\n        return this.confmng("component", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "execute",\n    value: function execute() {\n      console.warn(\'not implement\');\n    }\n  }, {\n    key: "contents",\n    value: function contents(p1) {\n      console.warn(\'not implement\');\n    }\n  }, {\n    key: "tag",\n    value: function tag(prm) {\n      try {\n        return this.confmng("tag", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "isInited",\n    value: function isInited(prm) {\n      try {\n        return this.confmng("isInited", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "suspend",\n    value: function suspend(prm) {\n      try {\n        return this.confmng("suspend", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "innerTgt",\n    value: function innerTgt(prm) {\n      try {\n        return this.confmng("innerTgt", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/ModConf.js?')},"./node_modules/mofron/src/core/Window.js":
/*!************************************************!*\
  !*** ./node_modules/mofron/src/core/Window.js ***!
  \************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Window.js\n * @brief mofron window class\n */\n//const Base   = require("./Base.js");\n//const Component = require("../tag/Component.js");\nvar comutl = __webpack_require__(/*! ./../util/common.js */ "./node_modules/mofron/src/util/common.js");\n\nmodule.exports = /*#__PURE__*/function (_mofron$class$Compone) {\n  _inherits(_class, _mofron$class$Compone);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Window\');\n\n      _this.confmng().add("landscapeEvent", {\n        type: "event",\n        list: true\n      });\n\n      _this.confmng().add("portraitEvent", {\n        type: "event",\n        list: true\n      }); //this.confmng().add("event", { type: "Event", list: true });\n\n\n      _this.initOrientation();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "isPortrait",\n    value: function isPortrait() {\n      try {\n        return window.innerHeight > window.innerWidth ? true : false;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "isLandscape",\n    value: function isLandscape() {\n      try {\n        return window.innerHeight < window.innerWidth ? true : false;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "resizeEvent",\n    value: function resizeEvent(func, prm, tlag) {\n      try {\n        var que_buf = null;\n        var param = prm;\n        var time_lag = undefined === tlag ? 200 : tlag;\n\n        if (\'function\' !== typeof func || \'number\' !== typeof time_lag) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        window.addEventListener(\'resize\', function () {\n          try {\n            clearTimeout(que_buf);\n            que_buf = setTimeout(func, time_lag, param);\n          } catch (e) {\n            console.error(e.stack);\n            throw new Error();\n          }\n        }, false);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "initOrientation",\n    value: function initOrientation() {\n      try {\n        if (undefined !== screen.orientation && null === screen.orientation.onchange) {\n          screen.orientation.onchange = this.orientationHandler;\n        } else if (null === screen.onmozorientationchange) {\n          screen.onmozorientationchange = this.orientationHandler;\n        } else if (null === screen.onmsorientationchange) {\n          screen.onmsorientationchange = this.orientationHandler;\n        } else {\n          window.addEventListener("orientationchange", this.orientationHandler);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "orientationHandler",\n    value: function orientationHandler(evt) {\n      try {\n        var ef = null;\n\n        if ("landscape-primary" === screen.mozOrientation || "landscape-secondary" === screen.mozOrientation || "landscape-primary" === screen.orientation.type || "landscape-secondary" === screen.orientation.type) {\n          /* landscape event */\n          ef = this.landscapeEvent();\n        } else if ("portrait-primary" === screen.mozOrientation || "portrait-secondary" === screen.mozOrientation || "portrait-primary" === screen.orientation.type || "portrait-secondary" === screen.orientation.type) {\n          /* vertical event */\n          ef = this.portraitEvent();\n        } else {\n          if (window.innerHeight < window.innerWidth) {\n            /* landscape event */\n            ef = this.landscapeEvent();\n          } else {\n            /* portrait event */\n            ef = this.portraitEvent();\n          }\n        }\n\n        for (var eidx in ef) {\n          ef[eidx].exec(this, evt);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "landscapeEvent",\n    value: function landscapeEvent(fnc, prm) {\n      try {\n        return this.confmng("landscapeEvent", fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "portraitEvent",\n    value: function portraitEvent(fnc, prm) {\n      try {\n        return this.confmng("portraitEvent", fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "eventDom",\n    value: function eventDom() {\n      return this;\n    }\n  }, {\n    key: "getRawDom",\n    value: function getRawDom() {\n      return window;\n    }\n  }, {\n    key: "event",\n    value: function event(prm) {\n      try {\n        var ret = _get(_getPrototypeOf(_class.prototype), "event", this).call(this, prm);\n\n        if (undefined === prm) {\n          return ret;\n        }\n\n        if (true === comutl.isinc(prm, "Event")) {\n          prm.execute();\n        } else if (true === Array.isArray(prm)) {\n          for (var pidx in prm) {\n            prm[pidx].execute();\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(mofron["class"].Component);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/Window.js?')},"./node_modules/mofron/src/core/dom/Attrs.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Attrs.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Attrs.js\n * @author simpart\n */\nvar DomConf = __webpack_require__(/*! ./DomConf.js */ "./node_modules/mofron/src/core/dom/DomConf.js");\n\nmodule.exports = /*#__PURE__*/function (_DomConf) {\n  _inherits(_class, _DomConf);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   * @param tgt : (object) target adom object\n   */\n  function _class(tgt) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, tgt);\n\n      _this.name(\'Attrs\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * set style\n   *\n   * @param key : (string) style key\n   * @param val : (string) style value\n   */\n\n\n  _createClass(_class, [{\n    key: "domSet",\n    value: function domSet(key, val) {\n      try {\n        this.dom().getRawDom().setAttribute(key, val);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domRem",\n    value: function domRem(key) {\n      try {\n        this.dom().getRawDom().removeAttribute(key);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get attribute value from rawdom\n     *\n     * @param key : (string) style key\n     * @return (object) style contents\n     * @return (string) style contents value\n     */\n\n  }, {\n    key: "domGet",\n    value: function domGet(key) {\n      try {\n        return this.dom().getRawDom().getAttribute(key);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        var ret = \'\';\n        var conts = this.get();\n\n        for (var cidx in conts) {\n          ret += null === conts[cidx] ? cidx : cidx + \'="\' + conts[cidx] + \'"\';\n          ret += " ";\n        }\n\n        return "" === ret ? "" : ret.substring(0, ret.length - 1);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(DomConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Attrs.js?')},"./node_modules/mofron/src/core/dom/Class.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Class.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Class.js\n * @author simpart\n */\nvar DomConf = __webpack_require__(/*! ./DomConf.js */ "./node_modules/mofron/src/core/dom/DomConf.js");\n\nmodule.exports = /*#__PURE__*/function (_DomConf) {\n  _inherits(_class, _DomConf);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   * @param tgt : (object) target adom object\n   */\n  function _class(tgt) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, tgt);\n\n      _this.name(\'Class\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "set",\n    value: function set(prm, opt) {\n      try {\n        if (!("string" === typeof prm || true === Array.isArray(prm))) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        var set_prm = {};\n\n        if ("string" === typeof prm) {\n          set_prm[prm] = "";\n        } else {\n          for (var pidx in prm) {\n            if ("string" !== typeof prm[pidx]) {\n              throw new Error("invalid parameter");\n            }\n\n            set_prm[prm[pidx]] = "";\n          }\n        }\n\n        _get(_getPrototypeOf(_class.prototype), "set", this).call(this, set_prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "get",\n    value: function get() {\n      try {\n        var ret = [];\n\n        var cls = _get(_getPrototypeOf(_class.prototype), "get", this).call(this);\n\n        for (var cidx in cls) {\n          ret.push(cidx);\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set class name to rowdom\n     *\n     * @param key : (string) style key\n     * @param val : (string) style value\n     */\n\n  }, {\n    key: "domSet",\n    value: function domSet(key, val) {\n      try {\n        this.dom().getRawDom().classList.add(key);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domRem",\n    value: function domRem(key) {\n      try {\n        this.dom().getRawDom().classList.remove(key);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get class name from rawdom\n     *\n     * @return (object) style contents\n     * @return (string) style contents value\n     */\n\n  }, {\n    key: "domGet",\n    value: function domGet() {\n      try {\n        var clnm = this.dom().getRawDom().className;\n\n        if (undefined === clnm || null === clnm || \'\' === clnm) {\n          return null;\n        }\n\n        return clnm.split(\' \');\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        var ret = \'\';\n        var conts = this.get();\n\n        for (var idx in conts) {\n          ret += conts[idx] + " ";\n        }\n\n        return \'\' === ret ? \'\' : \'class="\' + ret.substring(0, ret.length - 1) + \'"\';\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(DomConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Class.js?')},"./node_modules/mofron/src/core/dom/Dom.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Dom.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Dom.js\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ../Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nvar Class = __webpack_require__(/*! ./Class.js */ "./node_modules/mofron/src/core/dom/Class.js");\n\nvar Style = __webpack_require__(/*! ./Style.js */ "./node_modules/mofron/src/core/dom/Style.js");\n\nvar Attrs = __webpack_require__(/*! ./Attrs.js */ "./node_modules/mofron/src/core/dom/Attrs.js");\n\nvar Props = __webpack_require__(/*! ./Props.js */ "./node_modules/mofron/src/core/dom/Props.js");\n\nvar Tree = __webpack_require__(/*! ../tree/Tree.js */ "./node_modules/mofron/src/core/tree/Tree.js");\n\nvar IDX_CLASS = 0;\nvar IDX_STYLE = 1;\nvar IDX_ATTRS = 2;\nvar IDX_PROPS = 3;\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   */\n  function _class(tc, cmp) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Dom\');\n\n      _this.confmng().add("tag", {\n        type: "string"\n      });\n\n      _this.confmng().add("component", {\n        type: "Component"\n      });\n\n      _this.confmng().add("text", {\n        type: "string",\n        init: ""\n      });\n\n      _this.confmng().add("dummy", {\n        type: "boolean",\n        init: false\n      });\n\n      _this.m_tree = new Tree(_assertThisInitialized(_this));\n      _this.m_rawdom = null;\n      _this.m_conf = [new Class(_assertThisInitialized(_this)), new Style(_assertThisInitialized(_this)), new Attrs(_assertThisInitialized(_this)), new Props(_assertThisInitialized(_this))];\n\n      if ("string" === typeof tc) {\n        _this.tag(tc);\n\n        _this.component(cmp);\n      } else if (undefined !== tc) {\n        _this.config(tc);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * tag name setter / getter\n   *\n   * @param tg : (string) tag name (option)\n   * @return (string) tag name\n   */\n\n\n  _createClass(_class, [{\n    key: "tag",\n    value: function tag(tg) {\n      try {\n        return this.confmng("tag", tg);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * component getter / setter\n     * \n     * @param cmp (object) mofron.Component\n     * @return (object) mofron.Component\n     */\n\n  }, {\n    key: "component",\n    value: function component(cmp) {\n      try {\n        return this.confmng("component", cmp);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "getTree",\n    value: function getTree() {\n      try {\n        return this.m_tree;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "child",\n    value: function child(chd, idx) {\n      try {\n        if (undefined === chd) {\n          /* getter */\n          return this.m_tree.getChild();\n        }\n        /* setter */\n\n\n        this.m_tree.addChild(chd, idx);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "parent",\n    value: function parent(prm) {\n      try {\n        return this.m_tree.parent(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "conf",\n    value: function conf(kv, opt, idx) {\n      try {\n        var cnf = this.m_conf[idx];\n\n        if (undefined === kv) {\n          /* get style object */\n          return cnf;\n        } else if (\'string\' === typeof kv) {\n          /* get style value of the key */\n          return cnf.get(kv);\n        }\n        /* setter */\n\n\n        cnf.set(kv, opt);\n        this.value(null);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * style setter / getter\n     *\n     * @param kv : (object) key-value object\n     * @param opt: (object) option\n     * @return (string) : value of style\n     * @return (object) : style object\n     */\n\n  }, {\n    key: "style",\n    value: function style(kv, opt) {\n      try {\n        if (undefined !== opt && true === opt.bpref) {\n          for (var key in kv) {\n            kv["webkit-" + key] = kv[key];\n            kv["-moz-" + key] = kv[key];\n            kv["-o-" + key] = kv[key];\n            kv["-ms-" + key] = kv[key];\n          }\n        }\n\n        return this.conf(kv, opt, IDX_STYLE);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * tag attribute setter / getter\n     *\n     * @param kv  : (object/string) key-value object / key of attribute\n     * @param val : (object) value of attribute\n     * @return\n     */\n\n  }, {\n    key: "attrs",\n    value: function attrs(kv, opt) {\n      try {\n        return this.conf(kv, opt, IDX_ATTRS);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * dom property setter / getter\n     * \n     * @param kv  : (object/string) key-value object / key of\n     * @param val : (object)  value of property\n     */\n\n  }, {\n    key: "props",\n    value: function props(kv, opt) {\n      try {\n        return this.conf(kv, opt, IDX_PROPS);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * tag class name setter / getter\n     * \n     * @param name : (string) class name\n     */\n\n  }, {\n    key: "class",\n    value: function _class(prm, opt) {\n      try {\n        if (undefined === prm) {\n          return this.conf("class", opt, IDX_CLASS);\n        }\n\n        this.conf("string" === typeof prm ? [prm] : prm, opt, IDX_CLASS);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * tag contents text setter / getter\n     * \n     * @param cnt : (string) tag contents (option)\n     * @return (string) tag contents\n     */\n\n  }, {\n    key: "text",\n    value: function text(prm) {\n      try {\n        var ret = this.confmng("text", prm);\n\n        if (undefined !== prm && true === this.isPushed()) {\n          this.getRawDom().innerHTML = prm;\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * dom string getter\n     *\n     * @return (string) dom string\n     */\n\n  }, {\n    key: "value",\n    value: function value() {\n      try {\n        var chd = this.child();\n        var chd_ret = \'\';\n\n        for (var cidx in chd) {\n          chd_ret += chd[cidx].value();\n        }\n\n        if (true === this.dummy()) {\n          return chd_ret;\n        }\n\n        var ret = \'<\' + this.tag() + \' \';\n        /* set id attribute */\n\n        ret += \'id="\' + this.id() + \'" \';\n        /* set dom config */\n\n        var cnf = this.m_conf;\n        var cnf_val = null;\n\n        for (var idx in cnf) {\n          var _cnf_val = cnf[idx].toString();\n\n          if ("" !== _cnf_val) {\n            ret += _cnf_val + " ";\n          }\n        }\n\n        ret += \'>\';\n        /* set tag contents */\n\n        ret += this.text();\n        /* check single */\n\n        if (true === is_single(this.tag())) {\n          return ret;\n        }\n        /* set child value */\n\n\n        ret += chd_ret;\n        return ret + \'</\' + this.tag() + \'>\';\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * draw dom to target dom\n     * \n     * @param (key-value) push option\n     *     target   : push target object\n     *     child    : child flag\n     *     position : position of insertAdjacentHTML parameter\n     */\n\n  }, {\n    key: "push",\n    value: function push(opt) {\n      try {\n        if (true === mofron.ssr) {\n          return;\n        } else if (undefined === opt) {\n          throw new Error("invalid parameter");\n        }\n\n        if (true !== opt.child) {\n          opt.target.insertAdjacentHTML(undefined === opt.position ? \'beforeend\' : opt.position, this.value());\n        }\n\n        var props = this.props().get();\n\n        if (true === this.dummy()) {\n          this.m_rawdom = null !== this.parent() ? this.parent().getRawDom() : null;\n        } else {\n          if (null !== this.parent()) {\n            this.m_rawdom = this.parent().getRawDom().querySelector("#" + this.id());\n          } else {\n            this.m_rawdom = document.body.querySelector("#" + this.id());\n          }\n        }\n\n        this.props(props); // set property\n\n        /* notify push to children */\n\n        var chd = this.child();\n\n        for (var cidx in chd) {\n          chd[cidx].push({\n            target: this.m_rawdom,\n            child: true\n          });\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get adom status\n     *\n     * @return (boolean) true : this adom had pushed\n     * @return (boolean) false : this adom had not pushed\n     */\n\n  }, {\n    key: "isPushed",\n    value: function isPushed() {\n      try {\n        return null === this.m_rawdom ? false : true;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get pushed dom object from blowser\n     *\n     * @return (object) raw dom object\n     */\n\n  }, {\n    key: "getRawDom",\n    value: function getRawDom() {\n      try {\n        if (false === this.isPushed()) {\n          throw new Error(\'this dom is not pushed yet\');\n        }\n\n        return this.m_rawdom;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      try {\n        /* remove this object from parent dom */\n        if (true === this.isPushed()) {\n          this.getRawDom().remove();\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "dummy",\n    value: function dummy(prm) {\n      try {\n        return this.confmng("dummy", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n\nvar is_single = function is_single(prm) {\n  try {\n    if ("br" === prm || "hr" === prm || "input" === prm || "img" === prm) {\n      return true;\n    }\n\n    return false;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Dom.js?')},"./node_modules/mofron/src/core/dom/DomConf.js":
/*!*****************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/DomConf.js ***!
  \*****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file DomConf.js\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ../Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  function _class(dom) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("DomConf");\n\n      _this.confmng().add("lock", {\n        type: "key-value"\n      });\n\n      _this.confmng().add("dom", {\n        type: "Dom"\n      });\n\n      _this.confmng().add("listener", {\n        type: "array",\n        list: true\n      });\n\n      _this.dom(dom);\n\n      _this.m_conts = {};\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "dom",\n    value: function dom(prm) {\n      try {\n        return this.confmng("dom", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "lock",\n    value: function lock(key, val) {\n      try {\n        var lock = this.confmng().get("lock");\n\n        if (undefined === val) {\n          /* getter */\n          return undefined === lock[key] ? false : lock[key];\n        }\n        /* setter */\n\n\n        if ("boolean" !== typeof val) {\n          throw new Error("invalid parameter");\n        }\n\n        lock[key] = val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "chkval",\n    value: function chkval(kv) {\n      try {\n        if (!("object" === _typeof(kv) && false === Array.isArray(kv) && false === comutl.isinc(kv, "Base"))) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        for (var key in kv) {\n          if (null !== kv[key] && "object" === _typeof(kv[key])) {\n            throw new Error("invalid parameter");\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "set",\n    value: function set(kv, opt) {\n      try {\n        this.chkval(kv);\n        var p_opt = undefined === opt ? {} : opt;\n        var lis = [];\n\n        for (var key in kv) {\n          var old_kv = {};\n          var new_kv = {};\n          old_kv[key] = undefined === this.m_conts[key] ? null : this.m_conts[key];\n          new_kv[key] = kv[key];\n\n          if (null === kv[key]) {\n            /* delete config */\n            this.rem(key);\n            lis = this.listener(key);\n\n            for (var lidx in lis) {\n              lis[lidx][0](this.dom(), [new_kv[key], old_kv[key]], lis[lidx][1]);\n            }\n\n            if (true === p_opt.lock) {\n              this.lock(key, true);\n            }\n\n            continue;\n          }\n          /* setter */\n\n\n          if (true === p_opt.passive) {\n            if (null === this.get(key)) {\n              this.m_conts[key] = kv[key];\n            } else {\n              continue;\n            }\n          } else if (true === p_opt.forced) {\n            this.m_conts[key] = kv[key];\n            this.lock(key, false);\n          } else {\n            if (true === this.lock(key)) {\n              continue;\n            }\n\n            this.m_conts[key] = kv[key];\n          }\n\n          if (true === p_opt.lock) {\n            this.lock(key, true);\n          }\n\n          if (true === this.dom().isPushed()) {\n            /* target dom is already rendered */\n            this.domSet(key, kv[key]);\n          }\n\n          lis = this.listener(key);\n\n          for (var lidx2 in lis) {\n            lis[lidx2][0](this.dom(), [new_kv[key], old_kv[key]], lis[lidx2][1]);\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "get",\n    value: function get(key) {\n      try {\n        if (false === this.dom().isPushed()) {\n          if (undefined === key) {\n            return this.m_conts;\n          }\n\n          return undefined === this.m_conts[key] ? null : this.m_conts[key];\n        } else {\n          /* target is already rendered */\n          return undefined == this.domGet(key) ? null : this.domGet(key);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "rem",\n    value: function rem(key) {\n      try {\n        if (undefined !== this.m_conts[key]) {\n          delete this.m_conts[key];\n        }\n\n        if (true === this.dom().isPushed()) {\n          /* target dom is already rendered */\n          this.domRem(key);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domRem",\n    value: function domRem(key) {\n      try {\n        console.warn(\'not implement\');\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domSet",\n    value: function domSet(key, val) {\n      try {\n        console.warn(\'not implement\');\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domGet",\n    value: function domGet(key) {\n      try {\n        console.warn(\'not implement\');\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "listener",\n    value: function listener(key, fnc, prm) {\n      try {\n        if (undefined === fnc) {\n          /* getter */\n          var lis = this.confmng("listener");\n\n          if (undefined === key) {\n            return lis;\n          }\n\n          var ret = [];\n\n          for (var lidx in lis) {\n            if (key === lis[lidx][0]) {\n              ret.push([lis[lidx][1], lis[lidx][2]]);\n            }\n          }\n\n          return ret;\n        }\n\n        if ("string" !== typeof key || "function" !== typeof fnc) {\n          throw new Error("invalid parameter");\n        }\n\n        this.confmng("listener", [key, fnc, prm]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/DomConf.js?')},"./node_modules/mofron/src/core/dom/Props.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Props.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Props.js\n * @author simpart\n */\nvar DomConf = __webpack_require__(/*! ./DomConf.js */ "./node_modules/mofron/src/core/dom/DomConf.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_DomConf) {\n  _inherits(_class, _DomConf);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   * @param tgt : (object) target dom object\n   */\n  function _class(tgt) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, tgt);\n\n      _this.name(\'Prop\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "chkval",\n    value: function chkval(kv) {\n      try {\n        if (!("object" === _typeof(kv) && false === Array.isArray(kv) && false === comutl.isinc(kv, "Base"))) {\n          throw new Error(\'invalid parameter\');\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * set property\n     *\n     * @param key : (string) property key\n     * @param val : (string) property value\n     */\n\n  }, {\n    key: "domSet",\n    value: function domSet(key, val) {\n      try {\n        if (undefined === this.dom().getRawDom()[key]) {\n          throw new Error(key + \' is unknown property\');\n        }\n\n        this.dom().getRawDom()[key] = val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domRem",\n    value: function domRem(key) {\n      try {\n        if (undefined === this.dom().getRawDom()[key]) {\n          return;\n        }\n\n        delete this.dom().getRawDom()[key];\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get property value from rawdom\n     *\n     * @param key : (string) property key\n     * @return (string) property value\n     */\n\n  }, {\n    key: "domGet",\n    value: function domGet(key) {\n      try {\n        var ret = this.dom().getRawDom()[key];\n        return "" === ret ? undefined : ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        return "";\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(DomConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Props.js?')},"./node_modules/mofron/src/core/dom/Style.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/dom/Style.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Style.js\n * @author simpart\n */\nvar DomConf = __webpack_require__(/*! ./DomConf.js */ "./node_modules/mofron/src/core/dom/DomConf.js");\n\nmodule.exports = /*#__PURE__*/function (_DomConf) {\n  _inherits(_class, _DomConf);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   */\n  function _class(tgt) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, tgt);\n\n      _this.name(\'Style\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * set style\n   *\n   * @param key : (string) style key\n   * @param val : (string) style value\n   */\n\n\n  _createClass(_class, [{\n    key: "domSet",\n    value: function domSet(key, val) {\n      try {\n        this.dom().getRawDom().style[getcamel(key)] = val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get style value from rawdom\n     *\n     * @param key : (string) style key\n     * @return (object) style contents\n     * @return (string) style contents value\n     */\n\n  }, {\n    key: "domGet",\n    value: function domGet(key) {\n      try {\n        if (undefined === key) {\n          return this.dom().getRawDom().style;\n        }\n\n        var val = this.dom().getRawDom().style[getcamel(key)];\n        return undefined === val || "" === val ? null : val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "domRem",\n    value: function domRem(key) {\n      try {\n        this.dom().getRawDom().style[getcamel(key)] = "";\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        var ret = \'\';\n        var conts = this.get();\n\n        for (var cidx in conts) {\n          ret += cidx + \':\' + conts[cidx] + \';\';\n        }\n\n        return \'\' === ret ? \'\' : \'style="\' + ret + \'"\';\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(DomConf);\n\nvar getcamel = function getcamel(prm) {\n  try {\n    if (\'string\' !== typeof prm) {\n      throw new Error(\'invalid parameter\');\n    }\n\n    if (prm.length - 1 === prm.lastIndexOf(\'-\')) {\n      throw new Error(\'invalid parameter\');\n    }\n\n    var skip = false;\n\n    if (0 === prm.indexOf(\'-\')) {\n      skip = true;\n    }\n\n    var ret_val = prm;\n    var ret_buf = null;\n    var up_str = null;\n    var idx = null;\n\n    while (true) {\n      idx = ret_val.indexOf(\'-\');\n\n      if (-1 === idx) {\n        break;\n      }\n\n      up_str = ret_val.charAt(idx + 1).toUpperCase();\n      ret_buf = ret_val.substr(0, idx);\n\n      if (true === skip) {\n        skip = false;\n        ret_val = ret_buf + ret_val.substr(idx + 1);\n      } else {\n        ret_val = ret_buf + up_str + ret_val.substr(idx + 2);\n      }\n    }\n\n    return ret_val;\n  } catch (e) {\n    console.error(e.stack);\n    throw e;\n  }\n};\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/dom/Style.js?')},"./node_modules/mofron/src/core/tree/CompTree.js":
/*!*******************************************************!*\
  !*** ./node_modules/mofron/src/core/tree/CompTree.js ***!
  \*******************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file CompTree.js\n * @brief tree manager for component\n * @license MIT\n */\nvar Tree = __webpack_require__(/*! ./Tree.js */ "./node_modules/mofron/src/core/tree/Tree.js");\n\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nmodule.exports = /*#__PURE__*/function (_Tree) {\n  _inherits(_class, _Tree);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    _classCallCheck(this, _class);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(_class, [{\n    key: "addChild",\n    value: function addChild(chd, idx) {\n      try {\n        if (true === Array.isArray(chd)) {\n          /* parameter check */\n          for (var cidx in chd) {\n            this.addChild(chd[cidx], idx);\n          }\n\n          return;\n        }\n        /* set parent-child relation in component layer */\n        //super.addChild(chd, idx);\n\n        /* set parent-child relation in dom layer */\n\n\n        var rdom = chd.rootDom();\n\n        if (undefined === idx) {\n          this.target().childDom().child(rdom);\n        } else {\n          var tgt_tree = this.target().childDom().getTree();\n          var t_idx = tgt_tree.getIndex(this.target().child()[idx].rootDom()[0]);\n          tgt_tree.addChild(rdom, t_idx);\n        }\n        /* set parent-child relation in component layer */\n\n\n        _get(_getPrototypeOf(_class.prototype), "addChild", this).call(this, chd, idx);\n        /* check render */\n\n\n        if (true === this.target().isExists()) {\n          var layout = comp.layout();\n\n          for (var lidx in layout) {\n            /* set layout */\n            lo[lo_idx].execute();\n          }\n          /* render child */\n\n\n          cmputl.render(chd);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "replace",\n    value: function replace(o_chd, n_chd) {\n      try {\n        if (this.target().childDom().id() === o_chd.childDom().id()) {\n          /* old child is dom target, replace dom target */\n          this.target().childDom(n_chd.childDom());\n        }\n        /* set parent-child relation in component layer */\n\n\n        this.getChild().splice(this.getIndex(o_chd), 0, n_chd);\n        n_chd.parent(this.target());\n        /* set parent-child relation in dom layer */\n\n        var tgt_tree = o_chd.rootDom()[0].parent().getTree();\n        var rep_idx = tgt_tree.getIndex(o_chd.rootDom()[0]);\n        var n_rdom = n_chd.rootDom();\n\n        for (var ridx in n_rdom) {\n          tgt_tree.getChild().splice(rep_idx + parseInt(ridx), 0, n_rdom[ridx]);\n          n_rdom[ridx].parent(this.target().childDom());\n        }\n\n        if (true === o_chd.isExists()) {\n          cmputl.render(n_chd);\n        }\n\n        o_chd.destroy();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "delChild",\n    value: function delChild(chd) {\n      try {\n        /* release relational in dom layer */\n        var rdom = chd.rootDom();\n\n        for (var ridx in rdom) {\n          if (null !== rdom[ridx].parent()) {\n            rdom[ridx].parent().getTree().delChild(rdom[ridx]);\n          }\n        }\n        /* delete child component */\n\n\n        _get(_getPrototypeOf(_class.prototype), "delChild", this).call(this, chd);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Tree);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/tree/CompTree.js?')},"./node_modules/mofron/src/core/tree/Tree.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/core/tree/Tree.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports){eval('function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @file Tree.js\n * @brief basement tree manager\n * @license MIT\n */\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function () {\n  function _class(tgt, elm) {\n    _classCallCheck(this, _class);\n\n    try {\n      this.m_parent = null;\n      this.m_child = [];\n      this.elemName(tgt.name());\n      this.target(tgt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n\n  _createClass(_class, [{\n    key: "elemName",\n    value: function elemName(prm) {\n      try {\n        if (undefined === prm) {\n          if (undefined === this.m_elemnm) {\n            throw new Error("could not find element name");\n          }\n\n          return this.m_elemnm;\n        }\n\n        if ("string" !== typeof prm) {\n          throw new Error("invalid parameter");\n        }\n\n        this.m_elemnm = prm;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "target",\n    value: function target(prm) {\n      try {\n        if (undefined === prm) {\n          if (undefined === this.m_target) {\n            throw new Error("could not find target");\n          }\n\n          return this.m_target;\n        }\n\n        if (false === comutl.isinc(prm, this.elemName())) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.m_target = prm;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "getChild",\n    value: function getChild() {\n      try {\n        return this.m_child;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "addChild",\n    value: function addChild(chd, idx) {\n      try {\n        /* parameter check */\n        if (true === Array.isArray(chd)) {\n          for (var cidx in chd) {\n            this.addChild(chd[cidx], undefined !== idx ? idx + parseInt(cidx) : undefined);\n          }\n\n          return;\n        }\n\n        if (false === comutl.isinc(chd, this.elemName())) {\n          throw new Error(\'invalid parameter\');\n        }\n        /* set parent-child relation */\n\n\n        chd.parent(this.target());\n        /* add child */\n\n        if (undefined === idx) {\n          this.getChild().push(chd);\n        } else {\n          this.getChild().splice(idx, 0, chd);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "delChild",\n    value: function delChild(chd) {\n      try {\n        var del_idx = this.getIndex(chd);\n        this.getChild().splice(del_idx, 1);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "parent",\n    value: function parent(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          return undefined === this.m_parent ? null : this.m_parent;\n        }\n\n        if (false === comutl.isinc(prm, this.elemName())) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.m_parent = prm;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "getIndex",\n    value: function getIndex(prm) {\n      try {\n        var chd = this.getChild();\n\n        for (var cidx in chd) {\n          if (chd[cidx].id() === prm.id()) {\n            return parseInt(cidx);\n          }\n        }\n\n        throw new Error("invalid parameter");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}();\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/core/tree/Tree.js?')},"./node_modules/mofron/src/tag/Component.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/tag/Component.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file   Component.js\n * @brief  basement component class\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ../core/Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nvar CompTree = __webpack_require__(/*! ../core/tree/CompTree.js */ "./node_modules/mofron/src/core/tree/CompTree.js");\n\nvar Dom = mofron["class"].Dom;\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\nvar effutl = __webpack_require__(/*! ../util/effect.js */ "./node_modules/mofron/src/util/effect.js");\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize property, dom\n   *\n   * @param (mixed) component proterty\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("Component");\n\n      _this.confmng().add("rootDom", {\n        type: "Dom",\n        list: true,\n        target: "private"\n      });\n\n      _this.confmng().add("childDom", {\n        type: "Dom",\n        target: "private"\n      });\n\n      _this.confmng().add("styleDom", {\n        type: "Dom",\n        target: "private"\n      });\n\n      _this.confmng().add("eventDom", {\n        type: "Dom",\n        target: "private"\n      });\n\n      _this.confmng().add("isConf", {\n        type: "boolean",\n        target: "private"\n      });\n\n      _this.confmng().add("layout", {\n        type: "ModConf",\n        list: true\n      });\n\n      _this.confmng().add("effect", {\n        type: "ModConf",\n        list: true\n      });\n\n      _this.confmng().add("event", {\n        type: "ModConf",\n        list: true\n      });\n\n      _this.confmng().add("style", {\n        type: "Style"\n      });\n\n      _this.confmng().add("theme", {\n        type: "key-value"\n      });\n\n      _this.confmng().add("innerComp", {\n        type: "key-value",\n        target: "private"\n      });\n      /* initialize member */\n\n\n      _this.m_tree = new CompTree(_assertThisInitialized(_this));\n      /*** set config ***/\n\n      _this.shortForm("child");\n      /* user config */\n\n\n      if (undefined !== prm) {\n        _this.config(prm);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /*** dom method ***/\n\n  /**\n   * dom setter / getter\n   * \n   * @return (object) dom object\n   */\n\n\n  _createClass(_class, [{\n    key: "rootDom",\n    value: function rootDom(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          if (0 === this.confmng().get("rootDom").length) {\n            this.initDomConts();\n          }\n\n          return this.confmng().get("rootDom");\n        }\n        /* setter */\n\n\n        this.confmng().set("rootDom", prm);\n\n        if (null === this.childDom()) {\n          this.childDom(this.rootDom()[0]);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * dom target setter / getter\n     * \n     * @param tgt : (object) dom object\n     * @return (object) dom object\n     */\n\n  }, {\n    key: "childDom",\n    value: function childDom(tgt) {\n      try {\n        var ret = this.confmng("childDom", tgt);\n\n        if (null === ret) {\n          if (0 < this.rootDom().length) {\n            this.confmng("childDom", this.rootDom()[0]);\n            return this.confmng("childDom");\n          } else {\n            throw new Error("could not find child dom");\n          }\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get style target dom\n     *\n     * @param tgt : (object) dom object\n     * @return (object) dom object\n     */\n\n  }, {\n    key: "styleDom",\n    value: function styleDom(tgt) {\n      try {\n        var ret = this.confmng("styleDom", tgt);\n        return null === ret ? this.childDom() : ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get event target dom\n     *\n     * @param tgt : (object) dom object\n     * @return (object) dom object\n     */\n\n  }, {\n    key: "eventDom",\n    value: function eventDom(tgt) {\n      try {\n        var ret = this.confmng("eventDom", tgt);\n        return null === ret ? this.childDom() : ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "beforeRender",\n    value: function beforeRender() {\n      try {\n        cmputl.chdloop(this, "beforeRender");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "initDomConts",\n    value: function initDomConts(prm) {\n      try {\n        this.rootDom(new Dom(undefined === prm ? "div" : prm, this));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "afterRender",\n    value: function afterRender() {\n      try {\n        cmputl.chdloop(this, "afterRender");\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "getTree",\n    value: function getTree() {\n      try {\n        return this.m_tree;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /*** child method ***/\n\n    /**\n     * child component setter / getter\n     * \n     * @param chd : (object) child component\n     * @param chd : (object) child component array\n     * @return (array) : childlen object\n     */\n\n  }, {\n    key: "child",\n    value: function child(chd, idx) {\n      try {\n        this.rootDom();\n        var ct = true === cmputl.isinncmp(this) ? this.childDom().component().getTree() : this.getTree();\n\n        if (undefined === chd) {\n          /* getter */\n          return ct.getChild();\n        }\n        /* setter */\n\n\n        ct.addChild(chd, idx);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "parent",\n    value: function parent(prm) {\n      try {\n        return this.getTree().parent(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "innerComp",\n    value: function innerComp(key, val, defcmp) {\n      try {\n        var incmp = this.confmng().get("innerComp");\n\n        if (undefined === val) {\n          /* getter */\n          if (undefined === incmp[key]) {\n            this[key](new defcmp());\n          }\n\n          return incmp[key];\n        } else if (false === comutl.iscmp(val)) {\n          throw new Error("invalid parameter");\n        }\n        /* setter */\n\n\n        if (undefined !== incmp[key]) {\n          if (false === comutl.isinc(val, incmp[key].name())) {\n            throw new Error("invalid parameter");\n          }\n          /* rewrite component, replace target child */\n\n\n          var pnt = incmp[key].parent();\n\n          if (null !== pnt) {\n            pnt.getTree().replace(incmp[key], val);\n          }\n        }\n\n        incmp[key] = val;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /* component method */\n\n    /**\n     * execute effect\n     *\n     * @param (number) execute id\n     * @param (function, array) callback\n     * @return (boolean) execute result\n     */\n\n  }, {\n    key: "execEffect",\n    value: function execEffect(eid, cb, cbp) {\n      try {\n        return effutl.exec(cmputl.modconf(this, cmputl.IDX_EFFECT), eid, [cb, cbp]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "isExists",\n    value: function isExists() {\n      try {\n        return this.childDom().isPushed();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /*** user config method ***/\n\n    /**\n     * style getter / setter\n     *\n     * @return (object) style object\n     */\n\n  }, {\n    key: "style",\n    value: function style(kv, opt) {\n      try {\n        if ("string" === typeof kv) {\n          /* getter */\n          return this.styleDom().style(kv);\n        } else if ("Style" === comutl.isinc(kv)) {\n          /* setter */\n          var cnf = kv.get();\n\n          for (var cidx in cnf) {\n            var set = {};\n            set[cidx] = cnf[cidx];\n            this.styleDom().style(set, true === kv.lock(cidx) ? {\n              lock: true\n            } : undefined);\n          }\n        } else {\n          this.styleDom().style(kv, opt);\n          this.confmng("style", this.styleDom().style());\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "layout",\n    value: function layout(prm) {\n      try {\n        var ret = cmputl.modconf(this, 0, prm);\n\n        if (undefined !== prm && undefined !== ret) {\n          return true === Array.isArray(ret) && 1 === ret.length ? ret[0] : ret;\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "effect",\n    value: function effect(prm) {\n      try {\n        var ret = cmputl.modconf(this, 1, prm);\n\n        if (undefined !== prm && undefined !== ret) {\n          return true === Array.isArray(ret) && 1 === ret.length ? ret[0] : ret;\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "event",\n    value: function event(prm) {\n      try {\n        var ret = cmputl.modconf(this, 2, prm);\n\n        if (undefined !== prm && undefined !== ret) {\n          return true === Array.isArray(ret) && 1 === ret.length ? ret[0] : ret;\n        }\n\n        return ret;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "accessConfig",\n    value: function accessConfig(prm) {\n      try {\n        if (true === Array.isArray(prm)) {\n          for (var pidx in prm) {\n            this.accessConfig(prm[pidx]);\n          }\n\n          return;\n        } //            for (let pidx in prm) {\n        //                if (pidx === comutl.accdev()) {\n        //                    for (let pidx2 in prm[pidx][0]) {\n        //                        if (pidx2 === "os") {\n        //                            if (prm[pidx][0][pidx2] === comutl.accos()) {\n        //                                this.config(prm[pidx][1]);\n        //                            }\n        //                        } else if (pidx2 === "browser") {\n        //                            if (prm[pidx][0][pidx2] === comutl.accbrs()) {\n        //                                this.config(prm[pidx][1]);\n        //                            }\n        //                        }\n        //                    }\n        //                    if (0 === Object.keys(prm[pidx][0]).length) { \n        //                        this.config(prm[pidx][1]);\n        //                    }\n        //                }\n        //            }\n\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * \n     */\n\n  }, {\n    key: "theme",\n    value: function theme(prm) {\n      try {\n        return this.confmng("theme", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "template",\n    value: function template(tmpl, prm) {\n      try {\n        if (\'function\' !== typeof tmpl) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.child(tmpl(prm));\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      try {\n        /* destroy in component layer */\n        if (null === this.parent()) {\n          return;\n        }\n\n        this.parent().getTree().delChild(this);\n        /* destroy in dom layer */\n\n        var rdom = this.rootDom();\n\n        for (var ridx in rdom) {\n          rdom[ridx].destroy();\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "size",\n    value: function size(x, y, opt) {\n      try {\n        if (undefined === x) {\n          /* getter */\n          return [this.width(), this.height()];\n        }\n        /* setter */\n\n\n        this.width(x, opt);\n        this.height(y, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "width",\n    value: function width(prm, opt) {\n      try {\n        return cmputl.size(this, "width", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "height",\n    value: function height(prm, opt) {\n      try {\n        return cmputl.size(this, "height", prm, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /*** color method ***/\n\n  }, {\n    key: "color",\n    value: function color(c1, c2, c3) {\n      try {\n        if (undefined === c1) {\n          /* getter */\n          return [this.main_color(), this.base_color(), this.accent_color()];\n        }\n\n        var clr_tgt = ["mainColor", "baseColor", "accentColor"];\n\n        for (var cidx in clr_tgt) {\n          if (undefined === arguments[cidx]) {\n            continue;\n          } else if (true === comutl.isinc(arguments[cidx], "ConfArg")) {\n            arguments[cidx].exec(this, clr_tgt[cidx]);\n          } else {\n            this[clr_tgt[cidx]](arguments[cidx]);\n          }\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "mainColor",\n    value: function mainColor(prm, opt) {\n      /* interface */\n      return null;\n    }\n  }, {\n    key: "baseColor",\n    value: function baseColor(clr, opt) {\n      try {\n        /* interface */\n        return cmputl.color(this, "background", clr, opt);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "accentColor",\n    value: function accentColor(prm, opt) {\n      /* interface */\n      return null;\n    }\n  }, {\n    key: "visible",\n    value: function visible(flg, cbf, cbp) {\n      try {\n        return cmputl.visible(this, flg, cbf, cbp);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "config",\n    value: function config(p1, p2, p3, p4, p5) {\n      try {\n        this.rootDom();\n        return _get(_getPrototypeOf(_class.prototype), "config", this).call(this, p1, p2, p3, p4, p5);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Component.js?')},"./node_modules/mofron/src/tag/Effect.js":
/*!***********************************************!*\
  !*** ./node_modules/mofron/src/tag/Effect.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file Effect.js\n */\nvar ModConf = __webpack_require__(/*! ../core/ModConf.js */ "./node_modules/mofron/src/core/ModConf.js");\n\nvar comutl = mofron.util.common;\nvar effutl = mofron.util.effect;\n\nmodule.exports = /*#__PURE__*/function (_ModConf) {\n  _inherits(_class, _ModConf);\n\n  var _super = _createSuper(_class);\n\n  function _class(po) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Effect\');\n\n      _this.confmng().add("callback", {\n        type: "event",\n        list: true\n      });\n\n      _this.confmng().add("otCallback", {\n        type: "event",\n        list: true\n      });\n\n      _this.confmng().add("beforeEvent", {\n        type: "event",\n        list: true\n      });\n\n      _this.confmng().add("order", {\n        type: "number",\n        init: 0\n      });\n\n      _this.confmng().add("eid", {\n        type: "number",\n        init: 0\n      });\n\n      _this.confmng().add("speed", {\n        type: "number",\n        init: 0\n      });\n\n      _this.confmng().add("delay", {\n        type: "number",\n        init: 0\n      });\n\n      _this.confmng().add("forced", {\n        type: "boolean",\n        init: false\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * execute effect\n   * \n   * @param p2 (function) simple call back\n   */\n\n\n  _createClass(_class, [{\n    key: "execute",\n    value: function execute() {\n      try {\n        if (true === this.isSkipped(this.eid(), this.order())) {\n          return;\n        }\n\n        var evt = this.beforeEvent();\n\n        for (var eidx in evt) {\n          evt[eidx][0](this, this.component(), evt[eidx][1]);\n        }\n\n        var trans = false;\n\n        if (0 < this.speed() && null === this.component().style("transition")) {\n          effutl.transition(this, true);\n          trans = true;\n          this.otCallback(function (ts1, ts2, ts3) {\n            try {\n              mofron.util.effect.transition(ts3, false);\n            } catch (e) {\n              console.error(e.stack);\n              throw e;\n            }\n          }, this);\n        }\n        /* execute effect */\n\n\n        var exec = function exec(exe_eff) {\n          try {\n            exe_eff.contents(exe_eff.component());\n            exe_eff.isInited(true);\n            setTimeout(exe_eff.exeCallback, exe_eff.speed(), exe_eff);\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n\n        if (0 === this.delay() && 0 === this.speed() && false === trans) {\n          exec(this);\n        } else {\n          setTimeout(exec, this.delay() + 50, this);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "fexec",\n    value: function fexec() {\n      try {\n        var sus = this.suspend();\n        this.suspend(false);\n        this.execute();\n        this.suspend(sus);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "contents",\n    value: function contents(eid, cmp) {}\n  }, {\n    key: "beforeEvent",\n    value: function beforeEvent(fnc, prm) {\n      try {\n        return this.confmng("beforeEvent", fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "otCallback",\n    value: function otCallback(fnc, prm) {\n      try {\n        var ret = this.confmng("otCallback", fnc, prm);\n\n        if (undefined !== ret) {\n          this.confmng()["delete"]("otCallback");\n          return ret;\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * @param p1 (array) [function, param, one time flag]\n     */\n\n  }, {\n    key: "callback",\n    value: function callback(fnc, prm) {\n      try {\n        return this.confmng("callback", fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "exeCallback",\n    value: function exeCallback(eff) {\n      try {\n        /* execute callback */\n        var cb = eff.callback();\n\n        for (var cidx1 in cb) {\n          cb[cidx1][0](eff, eff.component(), cb[cidx1][1]);\n        }\n\n        var ocb = eff.otCallback();\n\n        for (var cidx2 in ocb) {\n          ocb[cidx2][0](eff, eff.component(), ocb[cidx2][1]);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "isSkipped",\n    value: function isSkipped(eid, ord) {\n      try {\n        if (true === this.suspend() || eid !== this.eid() || ord !== this.order()) {\n          return true;\n        }\n\n        return false;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * execute order number setter/getter\n     *\n     * @param p1 (number) execute order number\n     * @param p1 (undefined) call as getter\n     * @return (number) execute order number\n     */\n\n  }, {\n    key: "order",\n    value: function order(prm) {\n      try {\n        return this.confmng("order", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "eid",\n    value: function eid(prm) {\n      try {\n        return this.confmng("eid", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /*** default execute config ***/\n\n    /**\n     * effect speed setter/getter\n     *\n     * @param p1 (number) effect speed\n     * @param p1 (undefined) call as getter\n     * @return (number) effect speed\n     */\n\n  }, {\n    key: "speed",\n    value: function speed(prm) {\n      try {\n        return this.confmng("speed", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "delay",\n    value: function delay(prm) {\n      try {\n        return this.confmng("delay", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "forced",\n    value: function forced(prm) {\n      try {\n        return this.confmng("forced", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(ModConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Effect.js?')},"./node_modules/mofron/src/tag/Event.js":
/*!**********************************************!*\
  !*** ./node_modules/mofron/src/tag/Event.js ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file event.js\n * @author simpart\n */\nvar ModConf = __webpack_require__(/*! ../core/ModConf.js */ "./node_modules/mofron/src/core/ModConf.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_ModConf) {\n  _inherits(_class, _ModConf);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   */\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Event\');\n\n      _this.shortForm(\'listener\');\n\n      _this.confmng().add("listener", {\n        type: "event",\n        list: true\n      });\n\n      _this.confmng().add("eid", {\n        type: "number"\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n  /**\n   * set function for event listener\n   *\n   * @param fnc : (function) function for event listener\n   * @param prm : (mixed) function parameter (option)\n   */\n\n\n  _createClass(_class, [{\n    key: "listener",\n    value: function listener(fnc, prm) {\n      try {\n        return this.confmng("listener", fnc, prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "execListener",\n    value: function execListener(eprm) {\n      try {\n        if (true === this.suspend()) {\n          return;\n        }\n\n        var lis = this.listener();\n        var prm = null;\n\n        for (var lidx in lis) {\n          lis[lidx][0](this.component(), eprm, lis[lidx][1]);\n        }\n        /* execute effect */\n\n\n        if (null !== this.eid()) {\n          this.component().execEffect(this.eid());\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "execute",\n    value: function execute() {\n      try {\n        this.initevt();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "initevt",\n    value: function initevt() {\n      try {\n        if (false === this.isInited()) {\n          this.contents(this.component().eventDom());\n          this.isInited(true);\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "eid",\n    value: function eid(prm) {\n      try {\n        return this.confmng("eid", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(ModConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Event.js?')},"./node_modules/mofron/src/tag/Layout.js":
/*!***********************************************!*\
  !*** ./node_modules/mofron/src/tag/Layout.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file layout/Base.js\n * @brief Base class of layout\n */\nvar ModConf = __webpack_require__(/*! ../core/ModConf.js */ "./node_modules/mofron/src/core/ModConf.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_ModConf) {\n  _inherits(_class, _ModConf);\n\n  var _super = _createSuper(_class);\n\n  function _class(po) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Layout\');\n\n      _this.confmng().add("skip", {\n        type: "Component",\n        list: true\n      });\n\n      _this.confmng().add("execlog", {\n        type: "Component",\n        list: true\n      }); //this.m_execnt = 0;\n\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "execute",\n    value: function execute() {\n      try {\n        var cmp_chd = this.component().child();\n\n        for (var _cidx in cmp_chd) {\n          /* check skip */\n          if (true === this.isSkipped(cmp_chd[_cidx])) {\n            continue;\n          }\n\n          if (false === this.isExeced(cmp_chd[_cidx])) {\n            /* execute layout contents */\n            this.contents(parseInt(_cidx), cmp_chd[_cidx]);\n            this.confmng("execlog", cmp_chd[_cidx]);\n          }\n        }\n\n        this.isInited(true);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "isExeced",\n    value: function isExeced(cmp) {\n      try {\n        var elog = this.confmng("execlog");\n\n        for (var eidx in elog) {\n          if (elog[eidx].id() === cmp.id()) {\n            return true;\n          }\n        }\n\n        return false;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "contents",\n    value: function contents(idx, tgt) {\n      console.warn(\'not implement\');\n    }\n  }, {\n    key: "skip",\n    value: function skip(prm) {\n      try {\n        return this.confmng("skip", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "isSkipped",\n    value: function isSkipped(cmp) {\n      try {\n        var skp = this.skip();\n\n        for (var sidx in skp) {\n          if (skp[sidx].id() === cmp[cidx].id()) {\n            return true;\n          }\n        }\n\n        return false;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(ModConf);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/tag/Layout.js?')},"./node_modules/mofron/src/type/Color.js":
/*!***********************************************!*\
  !*** ./node_modules/mofron/src/type/Color.js ***!
  \***********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file  Color.js\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ../core/Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Color\');\n\n      _this.m_rgba = [null, null, null, null];\n      /* red, green, blue, alpha */\n\n      if (true !== Array.isArray(prm)) {\n        throw new Error("invalid parameter");\n      } else {\n        _this.rgba(prm[0], prm[1], prm[2], prm[3]);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "rgb",\n    value: function rgb(r, g, b) {\n      try {\n        var ret = this.rgba(r, g, b);\n        return undefined !== ret ? [ret[0], ret[1], ret[2]] : undefined;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get rgba value\n     * \n     * @return (object) rgba array object\n     *   [0] -> (number) red value\n     *   [1] -> (number) green value\n     *   [2] -> (number) blue value\n     *   [3] -> (number) alpha value\n     */\n\n  }, {\n    key: "rgba",\n    value: function rgba(red, green, blue, alpha) {\n      try {\n        if (undefined === red) {\n          /* getter */\n          return this.m_rgba;\n        }\n        /* setter */\n\n\n        var _red = red === undefined ? null : red;\n\n        var _green = green === undefined ? null : green;\n\n        var _blue = blue === undefined ? null : blue;\n\n        var _alpha = alpha === undefined ? 1 : alpha;\n\n        if (null === _red && null === _green && null === _blue) {} else if (null !== _red && null !== _green && null !== _blue) {\n          if (\'number\' !== typeof _red || \'number\' !== typeof _green || \'number\' !== typeof _blue) {\n            throw new Error(\'invalid parameter\');\n          }\n        } else {\n          throw new Error(\'invalid parameter\');\n        }\n\n        if (\'number\' !== typeof _alpha) {\n          throw new Error(\'invalid parameter\');\n        }\n\n        this.m_rgba[0] = _red;\n        this.m_rgba[1] = _green;\n        this.m_rgba[2] = _blue;\n        this.m_rgba[3] = _alpha;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n    /**\n     * get coloe style value\n     *\n     * @return (string) rgba(x,x,x,x)\n     * @return (string) none\n     * @note return \'none\' if rgb is null.\n     */\n\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        var rgba = this.rgba();\n        var red = rgba[0];\n        var green = rgba[1];\n        var blue = rgba[2];\n        var alpha = rgba[3];\n\n        if (null === red && null === green && null === blue) {\n          return \'none\';\n        }\n\n        return \'rgba(\' + red + \',\' + green + \',\' + blue + \',\' + alpha + \')\';\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/Color.js?')},"./node_modules/mofron/src/type/ConfArg.js":
/*!*************************************************!*\
  !*** ./node_modules/mofron/src/type/ConfArg.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file ConfArg.js\n * @brief config argument class\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ../core/Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  function _class() {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name("ConfArg");\n\n      _this.param(arguments);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "exec",\n    value: function exec(tgt, fnc) {\n      try {\n        var arg = this.param();\n\n        if (true === Array.isArray(fnc)) {\n          if (1 === fnc.length) {\n            this.exec(tgt, fnc[0]);\n          } else {\n            if (fnc.length < arg.length) {\n              throw new Error("mismatched config count");\n            }\n\n            for (var aidx in arg) {\n              if ("function" !== typeof tgt[fnc[aidx]]) {\n                console.warn("invalid config: " + fnc[aidx]);\n                continue;\n              }\n\n              if (true === comutl.isinc(arg[aidx], "ConfArg")) {\n                arg[aidx].exec(tgt, fnc[aidx]);\n              } else {\n                tgt[fnc[aidx]](arg[aidx]);\n              }\n            }\n          }\n\n          return;\n        } else if ("string" === typeof fnc) {\n          if ("function" !== typeof tgt[fnc]) {\n            console.warn("invalid config: " + fnc);\n            return;\n          }\n\n          if (0 === arg.length) {\n            tgt[fnc]();\n          } else if (1 === arg.length) {\n            tgt[fnc](arg[0]);\n          } else if (2 === arg.length) {\n            tgt[fnc](arg[0], arg[1]);\n          } else if (3 === arg.length) {\n            tgt[fnc](arg[0], arg[1], arg[2]);\n          } else if (4 === arg.length) {\n            tgt[fnc](arg[0], arg[1], arg[2], arg[3]);\n          } else {\n            tgt[fnc](arg[0], arg[1], arg[2], arg[3], arg[4]);\n          }\n        } else {\n          throw new Error("invalid parameter");\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "param",\n    value: function param(prm) {\n      try {\n        if (undefined === prm) {\n          /* getter */\n          if (undefined === this.m_param) {\n            throw new Error("could not find param");\n          }\n\n          return this.m_param;\n        }\n        /* setter */\n\n\n        if ("object" !== _typeof(prm)) {\n          throw new Error("invalid parameter");\n        }\n\n        var arg = [];\n        var hit = false;\n\n        for (var pidx = prm.length; pidx >= 0; pidx--) {\n          if (true === hit) {\n            arg.unshift(prm[pidx]);\n          } else if (undefined !== prm[pidx]) {\n            arg.unshift(prm[pidx]);\n            hit = true;\n          }\n        }\n\n        this.m_param = arg;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "addParam",\n    value: function addParam(prm) {\n      try {\n        this.m_param.push(prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/ConfArg.js?')},"./node_modules/mofron/src/type/EventFrame.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron/src/type/EventFrame.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file EventFrame.js\n */\nvar Base = __webpack_require__(/*! ../core/Base.js */ "./node_modules/mofron/src/core/Base.js");\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  /**\n   * initialize member\n   *\n   */\n  function _class(fnc, prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'EventFrame\');\n\n      _this.confmng().add("func", {\n        type: "function"\n      });\n\n      _this.func(fnc);\n\n      _this.param(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "func",\n    value: function func(prm) {\n      try {\n        return this.confmng("func", prm, {\n          type: "function"\n        });\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "param",\n    value: function param(prm) {\n      try {\n        if (undefined === prm) {\n          return this.m_param;\n        }\n\n        this.m_param = prm;\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "exec",\n    value: function exec(p1, p2) {\n      try {\n        if (undefined === p1) {\n          this.func()(undefined, undefined, this.param());\n        } else if (undefined === p2) {\n          this.func()(p1, undefined, this.param());\n        } else {\n          this.func()(p1, p2, this.param());\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/EventFrame.js?')},"./node_modules/mofron/src/type/PullConf.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/type/PullConf.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file pullConf.js\n * @brief pull type config argument class\n * @author simpart\n */\nvar ConfArg = __webpack_require__(/*! ./ConfArg.js */ "./node_modules/mofron/src/type/ConfArg.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_ConfArg) {\n  _inherits(_class, _ConfArg);\n\n  var _super = _createSuper(_class);\n\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      if (!(\'object\' === _typeof(prm) && false === Array.isArray(prm) && false === comutl.isinc(prm, "Base"))) {\n        throw new Error("invalid parameter");\n      }\n\n      _this = _super.call(this, prm);\n\n      _this.name("PullConf");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "exec",\n    value: function exec(tgt, fnc) {\n      try {\n        tgt[fnc]().config(this.param()[0]);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(ConfArg);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/PullConf.js?')},"./node_modules/mofron/src/type/size/Pixel.js":
/*!****************************************************!*\
  !*** ./node_modules/mofron/src/type/size/Pixel.js ***!
  \****************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file  Pixel.js\n * @brief pixel size data type\n * @author simpart\n */\nvar Size = __webpack_require__(/*! ./Size.js */ "./node_modules/mofron/src/type/size/Size.js");\n\nmodule.exports = /*#__PURE__*/function (_Size) {\n  _inherits(_class, _Size);\n\n  var _super = _createSuper(_class);\n\n  /**\n   *\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, prm, \'px\');\n\n      _this.name(\'Pixel\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "toPxnum",\n    value: function toPxnum() {\n      try {\n        return this.value();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Size);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/size/Pixel.js?')},"./node_modules/mofron/src/type/size/Rem.js":
/*!**************************************************!*\
  !*** ./node_modules/mofron/src/type/size/Rem.js ***!
  \**************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file  Rem.js\n * @brief rem size data type\n * @author simpart\n */\nvar Size = __webpack_require__(/*! ./Size.js */ "./node_modules/mofron/src/type/size/Size.js");\n\nvar comutl = mofron.util.common;\n\nmodule.exports = /*#__PURE__*/function (_Size) {\n  _inherits(_class, _Size);\n\n  var _super = _createSuper(_class);\n\n  /**\n   *\n   */\n  function _class(prm) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this, prm, \'rem\');\n\n      _this.name(\'Rem\');\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "toPixel",\n    value: function toPixel() {\n      try {\n        /* get html font-size */\n        var h_fsiz = document.documentElement.style["fontSize"];\n\n        if ("" === h_fsiz) {\n          h_fsiz = 625; // default size\n        } else {\n          h_fsiz = parseFloat(h_fsiz);\n        }\n        /* get body font-size */\n\n\n        var b_fsiz = document.body.style["fontSize"];\n\n        if ("" === b_fsiz) {\n          b_fsiz = "0.16"; // default size\n        } else {\n          b_fsiz = parseFloat(b_fsiz);\n        }\n\n        return this.value() * (b_fsiz * h_fsiz);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "calcu",\n    value: function calcu(prm, flg) {\n      try {\n        _get(_getPrototypeOf(_class.prototype), "calcu", this).call(this, prm, flg);\n\n        if (\'px\' === this.type()) {\n          this.value(this.px2Rem());\n          this.type(\'rem\');\n        }\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Size);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/size/Rem.js?')},"./node_modules/mofron/src/type/size/Size.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/type/size/Size.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * @file  Size.js\n * @brief size data type\n * @author simpart\n */\nvar Base = __webpack_require__(/*! ../../core/Base.js */ "./node_modules/mofron/src/core/Base.js");\n/**\n * @class Size\n * @brief Size Defined Class\n */\n\n\nmodule.exports = /*#__PURE__*/function (_Base) {\n  _inherits(_class, _Base);\n\n  var _super = _createSuper(_class);\n\n  /**\n   *\n   */\n  function _class(siz, tp) {\n    var _this;\n\n    _classCallCheck(this, _class);\n\n    try {\n      _this = _super.call(this);\n\n      _this.name(\'Size\');\n\n      _this.confmng().add("type", {\n        type: "string",\n        init: ""\n      });\n\n      _this.confmng().add("value", {\n        type: "number",\n        init: 0\n      });\n\n      _this.confmng().add("option", {\n        type: "object",\n        init: {}\n      });\n\n      if (\'number\' === typeof siz && \'string\' === typeof tp) {\n        _this.value(siz);\n\n        _this.type(tp);\n      } else {\n        throw new Error("invalid parameter");\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n\n    return _this;\n  }\n\n  _createClass(_class, [{\n    key: "type",\n    value: function type(prm) {\n      try {\n        return this.confmng("type", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "value",\n    value: function value(prm) {\n      try {\n        return this.confmng("value", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "option",\n    value: function option(prm) {\n      try {\n        return this.confmng("option", prm);\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toStyle",\n    value: function toStyle() {\n      try {\n        return [this.toString(), this.option()];\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      try {\n        return null === this.type() ? null : this.value() + this.type();\n      } catch (e) {\n        console.error(e.stack);\n        throw e;\n      }\n    }\n  }, {\n    key: "toPixel",\n    value: function toPixel() {\n      try {\n        throw new Error("not supported");\n      } catch (e) {\n        throw e;\n      }\n    }\n  }]);\n\n  return _class;\n}(Base);\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/type/size/Size.js?')},"./node_modules/mofron/src/util/common.js":
/*!************************************************!*\
  !*** ./node_modules/mofron/src/util/common.js ***!
  \************************************************/
/*! no static exports found */function(module,exports){eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * @file common.js\n * @brief common util functions\n */\nmofron.util.common = {\n  isinc: function isinc(obj, nm) {\n    try {\n      /* parameter check */\n      if (null === obj || 'object' !== _typeof(obj) || true === Array.isArray(obj) || \"function\" !== typeof obj.name || \"function\" !== typeof obj.confmng) {\n        return false;\n      }\n\n      var chk_nm = \"string\" === typeof nm ? [nm] : nm;\n      var chk_idx = 0;\n      var name_lst = obj.confmng(\"name\");\n\n      for (var idx in name_lst) {\n        if (chk_nm[chk_idx] === name_lst[idx]) {\n          chk_idx++;\n\n          if (chk_nm.length === chk_idx) {\n            return true;\n          }\n\n          continue;\n        }\n\n        if (0 < chk_idx) {\n          break;\n        }\n      }\n\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  iscmp: function iscmp(obj) {\n    try {\n      return comutl.isinc(obj, \"Component\");\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  isobj: function isobj(obj, nm) {\n    try {\n      return obj.name() === nm ? true : false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getcmp: function getcmp(prm) {\n    try {\n      return new mofron[\"class\"].Component(prm);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getcolor: function getcolor(prm) {\n    try {\n      if (null === prm || undefined === prm) {\n        return null;\n      } else if ('string' === typeof prm) {\n        if ('none' === prm) {\n          return new mofron[\"class\"].Color();\n        } else if (0 === prm.indexOf('rgb')) {\n          var rgb_clr = null;\n\n          if (0 === prm.indexOf('rgba(')) {\n            rgb_clr = prm.substring(5);\n          } else if (0 === prm.indexOf('rgb(')) {\n            rgb_clr = prm.substring(4);\n          } else {\n            throw new Error('invalid parameter');\n          }\n\n          rgb_clr = rgb_clr.substring(0, rgb_clr.length - 1);\n          rgb_clr = rgb_clr.split(',');\n\n          if (3 === rgb_clr.length) {\n            return new mofron[\"class\"].Color([parseInt(rgb_clr[0]), parseInt(rgb_clr[1]), parseInt(rgb_clr[2])]);\n          } else if (4 === rgb_clr.length) {\n            return new mofron[\"class\"].Color([parseInt(rgb_clr[0]), parseInt(rgb_clr[1]), parseInt(rgb_clr[2]), parseInt(rgb_clr[3])]);\n          } else {\n            throw new Error('invalid parameter');\n          }\n        } else if (0 === prm.indexOf('#')) {\n          /* hex */\n          var hex_clr = prm.substring(1);\n\n          if (6 !== hex_clr.length) {\n            throw new Error('invalid parameter');\n          }\n\n          return new mofron[\"class\"].Color([parseInt(hex_clr.substring(0, 2), 16), parseInt(hex_clr.substring(2, 4), 16), parseInt(hex_clr.substring(4, 6), 16)]);\n        } else {\n          /* name */\n          if ('string' !== typeof prm) {\n            throw new Error('invalid parameter');\n          }\n\n          switch (prm) {\n            case 'black':\n              return new mofron[\"class\"].Color([0, 0, 0]);\n\n            case 'gray':\n              return new mofron[\"class\"].Color([128, 128, 128]);\n\n            case 'silver':\n              return new mofron[\"class\"].Color([192, 192, 192]);\n\n            case 'white':\n              return new mofron[\"class\"].Color([255, 255, 255]);\n\n            case 'blue':\n              return new mofron[\"class\"].Color([0, 0, 255]);\n\n            case 'navy':\n              return new mofron[\"class\"].Color([0, 0, 128]);\n\n            case 'teal':\n              return new mofron[\"class\"].Color([0, 128, 128]);\n\n            case 'green':\n              return new mofron[\"class\"].Color([0, 128, 0]);\n\n            case 'lime':\n              return new mofron[\"class\"].Color([0, 255, 0]);\n\n            case 'aqua':\n              return new mofron[\"class\"].Color([0, 255, 255]);\n\n            case 'yellow':\n              return new mofron[\"class\"].Color([255, 255, 0]);\n\n            case 'red':\n              return new mofron[\"class\"].Color([255, 0, 0]);\n\n            case 'fuchsia':\n              return new mofron[\"class\"].Color([255, 0, 255]);\n\n            case 'olive':\n              return new mofron[\"class\"].Color([128, 128, 0]);\n\n            case 'purple':\n              return new mofron[\"class\"].Color([128, 0, 128]);\n\n            case 'maroon':\n              return new mofron[\"class\"].Color([128, 0, 0]);\n\n            default:\n              throw new Error('not supported color');\n          }\n        }\n      } else if (true === Array.isArray(prm)) {\n        return new mofron[\"class\"].Color(prm);\n      } else if (true === comutl.isinc(prm, 'Color')) {\n        return prm;\n      } else {\n        throw new Error('invalid parameter');\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getsize: function getsize(prm) {\n    try {\n      var siz = null;\n      /* parameter check */\n\n      if ('string' !== typeof prm) {\n        if (null === prm || undefined === prm) {\n          return null;\n        } else if (true === comutl.isinc(prm, \"Size\")) {\n          return prm;\n        } else {\n          throw new Error('invalid parameter');\n        }\n      }\n      /* get size type */\n\n\n      var stype = ['px', '%', 'rem', 'em', 'vw', 'vh'];\n      var ptype = null;\n\n      for (var sidx in stype) {\n        if (2 !== prm.split(stype[sidx]).length) {\n          continue;\n        }\n\n        ptype = stype[sidx];\n        break;\n      }\n\n      if (null === ptype) {\n        throw new Error('not supported size type');\n      }\n      /* get value */\n\n\n      var sval = null;\n      sp_prm = prm.split(ptype);\n\n      if (2 === sp_prm[0].split('.').length) {\n        sval = parseFloat(sp_prm[0]);\n      } else {\n        sval = parseInt(sp_prm[0]);\n      }\n\n      if ('px' === ptype) {\n        return new mofron[\"class\"].Pixel(sval);\n      } else if ('rem' === ptype) {\n        return new mofron[\"class\"].Rem(sval);\n      } else {\n        return new mofron[\"class\"].Size(sval, ptype);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  sizetype: function sizetype(prm) {\n    try {\n      var size = comutl.getsize(prm);\n      return null === size ? null : size.type();\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  sizesum: function sizesum(p1, p2) {\n    try {\n      var prm1 = 'string' === typeof p1 ? comutl.getsize(p1) : p1;\n      var prm2 = 'string' === typeof p2 ? comutl.getsize(p2) : p2;\n\n      if (null == prm1 && true === comutl.isinc(prm2, ['Base', 'Size'])) {\n        return prm2.toString();\n      } else if (null == prm2 && true === comutl.isinc(prm1, ['Base', 'Size'])) {\n        return prm1.toString();\n      } else if (null === prm1 && null === prm2) {\n        return null;\n      }\n\n      if (true !== comutl.isinc(prm1, ['Base', 'Size']) || true !== comutl.isinc(prm2, ['Base', 'Size'])) {\n        throw new Error('invalid parameter');\n      }\n\n      if (prm1.type() !== prm2.type()) {\n        if (undefined === prm1.toPxnum() || undefined === prm2.toPxnum()) {\n          throw new Error('not supported type');\n        }\n\n        return new mofron[\"class\"].Pixel(prm1.toPxnum() + prm2.toPxnum()).toString();\n      } else {\n        var val_1 = comutl.roundup(prm1.value());\n        var val_2 = comutl.roundup(prm2.value());\n        return comutl.roundup(val_1 + val_2) + prm1.type();\n      }\n    } catch (e) {\n      throw e;\n    }\n  },\n  sizediff: function sizediff(p1, p2) {\n    try {\n      var prm2 = 'string' === typeof p2 ? comutl.getsize(p2) : p2;\n\n      if (true !== comutl.isinc(prm2, \"Size\")) {\n        throw new Error('not supported type');\n      }\n\n      var prm2_buf = comutl.getsize(prm2.toString());\n      prm2_buf.value(prm2_buf.value() * -1);\n      return comutl.sizesum(p1, prm2_buf);\n    } catch (e) {\n      throw e;\n    }\n  },\n  roundup: function roundup(prm) {\n    try {\n      var flo = comutl.flo2int(prm);\n\n      if (1000 >= flo[1]) {\n        return prm;\n      }\n\n      return Math.floor(flo[0] / flo[1] * 1000) / 1000;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  flo2int: function flo2int(prm) {\n    try {\n      if ('number' !== typeof prm) {\n        throw new Error('invalid parameter');\n      }\n\n      var chk = null;\n      var pos = 0;\n      var wei = 1;\n      chk = prm + '';\n      pos = chk.indexOf('.');\n\n      if (-1 === pos) {\n        return [prm, 1];\n      }\n\n      for (pos = chk.length - 1 - pos; 0 < pos; pos--) {\n        wei = wei * 10;\n      }\n\n      return [prm * wei, wei];\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  chkacc: function chkacc(opt) {\n    try {\n      for (var oidx in opt) {\n        if (\"device\" === oidx) {\n          if (opt[oidx] !== comutl.accdev()) {\n            return false;\n          }\n        } else if (\"os\" === oidx) {\n          if (opt[oidx] !== comutl.accos()) {\n            return false;\n          }\n        } else if (\"browser\" === oidx) {\n          if (opt[oidx] !== comutl.accbrs()) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  accdev: function accdev() {\n    try {\n      var ua = window.navigator.userAgent;\n\n      if (ua.indexOf('iPhone') > 0 || ua.indexOf('iPod') > 0 || ua.indexOf('Android') > 0 && ua.indexOf('Mobile') > 0) {\n        return 'mobile';\n      } else if (ua.indexOf('iPad') > 0 || ua.indexOf('Android') > 0) {\n        return 'tablet';\n      } else {\n        return 'display';\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  accos: function accos() {\n    try {\n      var ua = window.navigator.userAgent;\n\n      if (ua.indexOf('iPhone') > 0 || ua.indexOf('iPod') > 0 || ua.indexOf('iPad') > 0) {\n        return 'ios';\n      } else if (ua.indexOf('Android') > 0) {\n        return 'android';\n      } else if (ua.indexOf('Windows') > 0) {\n        return 'windows';\n      } else if (ua.indexOf('Mac OS') > 0) {\n        return 'mac';\n      } else if (ua.indexOf('Linux') > 0) {\n        return 'linux';\n      } else {\n        return 'other';\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  accbrs: function accbrs() {\n    try {\n      var ua = window.navigator.userAgent.toLowerCase();\n\n      if (ua.indexOf('msie') !== -1 || ua.indexOf('trident') !== -1) {\n        return 'ie';\n      } else if (ua.indexOf('edge') != -1) {\n        return 'edge';\n      } else if (ua.indexOf('chrome') != -1) {\n        return 'chrome';\n      } else if (ua.indexOf('safari') != -1) {\n        return 'safari';\n      } else if (ua.indexOf('firefox') != -1) {\n        return 'firefox';\n      } else if (ua.indexOf('opera') != -1) {\n        return 'opera';\n      } else {\n        return 'other';\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  addhead: function addhead(tag, atr, txt) {\n    try {\n      var conts = \"<\" + tag + \" \";\n      /* set attributes */\n\n      for (var aidx in atr) {\n        conts += aidx + '=' + atr[aidx] + ' ';\n      }\n\n      conts = conts.substring(0, conts.length - 1) + \">\";\n\n      if ('link' !== tag && 'meta' !== tag && 'base' !== tag) {\n        /* set contents */\n        conts += txt + \"</\" + tag + \">\";\n      }\n\n      if (undefined !== mofron.ssr) {\n        mofron.ssr.head(conts);\n      } else {\n        document.head.insertAdjacentHTML('beforeend', conts);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nvar comutl = mofron.util.common;\nmodule.exports = mofron.util.common;\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/common.js?")},"./node_modules/mofron/src/util/component.js":
/*!***************************************************!*\
  !*** ./node_modules/mofron/src/util/component.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports){eval('var _arguments = arguments;\n\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * @file component.js\n * @brief util functions for component\n * @license MIT\n */\nvar comutl = mofron.util.common;\nmofron.util.component = {\n  /*** define ***/\n  IDX_LAYOUT: 0,\n  IDX_EFFECT: 1,\n  IDX_EVENT: 2,\n  chdloop: function chdloop(cmp, key, p1, p2, p3) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      var _chd = cmp.child();\n\n      var argc = _arguments.length;\n\n      for (var cidx in _chd) {\n        if (2 === argc) {\n          _chd[cidx][key](p1);\n        } else if (3 === argc) {\n          _chd[cidx][key](p1, p2);\n        } else if (4 === argc) {\n          _chd[cidx][key](p1, p2, p3);\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  ischild: function ischild(pnt, cmp) {\n    try {\n      var ret = false;\n      var pchd = pnt.getTree().child();\n\n      for (var cidx in pchd) {\n        if (true === comutl.ischild(chd[cidx], cmp)) {\n          return true;\n        } else if (chd[cidx].id() === cmp.id()) {\n          return true;\n        }\n      }\n\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  isinncmp: function isinncmp(cmp) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      var chd_cmp = cmp.childDom().component();\n\n      if (null === chd_cmp || null === chd_cmp.getTree().parent()) {\n        return false;\n      }\n\n      var pnt_buf = chd_cmp.getTree().parent();\n\n      while (null !== pnt_buf) {\n        if (cmp.id() === pnt_buf.id()) {\n          /* target is inner component */\n          return true;\n        }\n\n        pnt_buf = pnt_buf.getTree().parent();\n      }\n\n      return false;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  modconf: function modconf(cmp, idx, po) {\n    try {\n      if (true === comutl.isinc(po, "ModConf") && true === po.innerTgt() && true === cmputl.isinncmp(cmp)) {\n        return cmputl.modconf(cmp.childDom().component(), idx, po);\n      }\n\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      var cnf_key = ["layout", "effect", "event"];\n\n      if (undefined === cnf_key[idx]) {\n        throw new Error(\'invalid parameter\');\n      }\n\n      if (true === Array.isArray(po)) {\n        for (var pidx in po) {\n          cmputl.modconf(cmp, idx, po[pidx]);\n        }\n\n        return;\n      }\n\n      if (false === comutl.isinc(po, "ModConf")) {\n        /* getter */\n        var mc_ret = cmp.confmng().get(cnf_key[idx]);\n\n        if ("object" !== _typeof(po) || false !== Array.isArray(po)) {\n          return mc_ret;\n        }\n\n        var ret = [];\n        var hit = null;\n\n        for (var midx in mc_ret) {\n          hit = true;\n\n          for (var _pidx in po) {\n            if (mc_ret[midx][_pidx]() !== po[_pidx]) {\n              hit = false;\n              break;\n            }\n          }\n\n          if (true === hit) {\n            ret.push(mc_ret[midx]);\n          }\n        }\n\n        return 0 === ret.length ? null : ret;\n      }\n      /* setter */\n\n\n      po.component(cmp);\n      cmp.confmng(cnf_key[idx], po);\n\n      if (true === cmp.isExists() && cmputl.IDX_EFFECT !== idx) {\n        po.execute();\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  initmconf: function initmconf(cmp, idx) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      var _chd2 = cmp.getTree().getChild();\n\n      for (var cidx in _chd2) {\n        cmputl.initmconf(_chd2[cidx], idx);\n      }\n      /* init module config */\n\n\n      if (cmputl.IDX_EFFECT === idx) {\n        /* init effect */\n        cmp.execEffect(true === cmp.visible() ? 0 : 1);\n      } else {\n        var cnf = cmputl.modconf(cmp, idx);\n\n        for (var cfidx in cnf) {\n          cnf[cfidx].execute();\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  exectheme: function exectheme(cmp, thm) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      var cmp_thm = cmp.theme();\n\n      var _chd3 = cmp.getTree().getChild();\n\n      for (var cidx in _chd3) {\n        /* add theme */\n        for (var ct_idx in cmp_thm) {\n          thm[ct_idx] = cmp_thm[ct_idx];\n        }\n\n        cmputl.exectheme(_chd3[cidx], thm);\n        /* execute theme */\n\n        for (var tidx in thm) {\n          if (true === comutl.isinc(_chd3[cidx], tidx)) {\n            if (null !== thm[tidx].target) {\n              /* replace component */\n              // not supported yet\n            } else {\n              _chd3[cidx].config(thm[tidx].config);\n            }\n          }\n        }\n      } //            /* call child theme */\n      //            let thm     = this.theme();\n      //          let cur_thm = {};\n      //          /* copy parent theme */\n      //            for (let pidx in prm) {\n      //                cur_thm[pidx] = JSON.parse(JSON.stringify(prm[pidx]));\n      //          }\n      //            /* copy this theme */\n      //          for (let tidx in thm) {\n      //                cur_thm[tidx] = JSON.parse(JSON.stringify(thm[tidx]));\n      //          }\n      //            \n      //            let chd = this.getChild(true);\n      //            for (let cidx in chd) {\n      //                chd[cidx].execTheme(cur_thm);\n      //          }\n      //            \n      //            let replace = (cp, tg, rp) => {\n      //                try {\n      //                    let ret = new rp();\n      //                    /* copy option */\n      //                    let tg_opt = tg.option();\n      //                    ret.option(tg_opt);\n      //                    \n      //                    if ( (undefined === tg_opt.child) && (0 !== tg.child().length) ) {\n      //                        ret.option({ child: tg.child() });\n      //                    }\n      //\n      //                    /* replace child */\n      //                    cp.updChild(tg, ret);\n      //                    return ret;\n      //                } catch (e) {\n      //                    console.error(e.stack);\n      //                    throw e;\n      //                }\n      //            };\n      //            \n      //            for (let cidx2 in chd) {\n      //                for (let thm_idx in cur_thm) {\n      //                    if (true === comutl.isinc(chd[cidx2], thm_idx)) {\n      //                        /* this child component is theme target */\n      //                        if ( (undefined !== cur_thm[thm_idx][0]) &&\n      //                             (undefined === cur_thm[thm_idx][1]) ) {\n      //                            /* theme type is class */\n      //                            replace(this, chd[cidx2], cur_thm[thm_iidx][0]);\n      //                        } else if ( (null !== cur_thm[thm_idx][0]) &&\n      //                                    (undefined !== cur_thm[thm_idx][1]) ) {\n      //                            /* theme type is class with option */\n      //                            replace(this, chd[cidx2], cur_thm[thm_idx][0]).option(cur_thm[thm_idx][1]);\n      //                        } else if ( (null === cur_thm[thm_idx][0]) &&\n      //                                    (undefined !== cur_thm[thm_idx][1]) ) {\n      //                            /* theme type is option */\n      //                            chd[cidx2].option(cur_thm[thm_idx][1]);\n      //                        }\n      //                    }\n      //                }\n      //            }\n\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  size: function size(cmp, key, val, opt) {\n    try {\n      /* setter */\n      if (false === comutl.iscmp(cmp) || "string" !== typeof key) {\n        throw new Error("invalid parameter");\n      }\n\n      if (undefined === val) {\n        /* getter */\n        return cmp.style(key);\n      }\n      /* setter */\n\n\n      var style_val = {};\n\n      if (null === comutl.getsize(val)) {\n        style_val[key] = null;\n      } else {\n        style_val[key] = comutl.getsize(val).toString();\n      }\n\n      cmp.config({\n        style: new mofron["class"].ConfArg(style_val, opt)\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  color: function color(cmp, key, val, opt) {\n    try {\n      if (false === comutl.iscmp(cmp) || "string" !== typeof key) {\n        throw new Error("invalid parameter");\n      }\n\n      if (undefined === val) {\n        /* getter */\n        return cmp.style(key);\n      }\n      /* setter */\n\n\n      var style_val = {};\n      style_val[key] = null === val ? null : comutl.getcolor(val).toString();\n      cmp.style(style_val, opt);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  display: function display(cmp, flg) {\n    try {\n      /* check parameter */\n      if (false === comutl.iscmp(cmp) || \'boolean\' !== typeof flg) {\n        throw new Error(\'invalid parameter\');\n      }\n\n      var buf = null;\n      var rdom = cmp.rootDom();\n\n      for (var ridx in rdom) {\n        if (true === flg) {\n          /* diplayed target dom, set display value from buffer */\n          if (\'none\' === rdom[ridx].style("display") && true === rdom[ridx].isPushed()) {\n            buf = cmputl.dispbuff(rdom[ridx]);\n            rdom[ridx].style({\n              "display": undefined === buf ? null : buf\n            });\n            cmputl.dispbuff(rdom[ridx], null);\n          }\n        } else {\n          /* hidden target dom, buffering display value */\n          buf = rdom[ridx].style("display");\n\n          if (\'none\' !== buf && null !== buf) {\n            cmputl.dispbuff(rdom[ridx], buf);\n          }\n\n          rdom[ridx].style({\n            "display": "none"\n          });\n        }\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  dispbuff: function dispbuff(dom, val) {\n    try {\n      if (false === comutl.isinc(dom, "Dom")) {\n        throw new Error("invalid parameter");\n      }\n\n      var dkey = dom.id() + "_display";\n\n      if (undefined === val) {\n        /* getter */\n        return dom.data(dkey);\n      }\n      /* setter */\n\n\n      dom.data(dkey, val);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  visible: function visible(cmp, vflg, ef, ep) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      if (undefined === vflg) {\n        /* getter */\n        if (false === cmp.isExists()) {\n          /* it does not rendered yet */\n          return false;\n        }\n\n        var doms = cmp.rootDom();\n\n        for (var didx in doms) {\n          if (\'none\' !== doms[didx].style(\'display\')) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n      /* setter */\n\n\n      if (\'boolean\' !== typeof vflg) {\n        throw new Error(\'invalid parameter\');\n      }\n\n      if (false === cmp.isExists()) {\n        /* render component */\n        cmputl.display(cmp, vflg);\n\n        if (true === vflg) {\n          cmputl.render(cmp, ef, ep);\n        }\n\n        return;\n      } else if (true === vflg) {\n        cmputl.display(cmp, vflg);\n      }\n\n      var scb = function scb() {\n        try {\n          if (false === vflg) {\n            cmputl.display(cmp, false);\n          }\n\n          if ("function" === typeof ef) {\n            ef(cmp, cmp.visible(), ep);\n          }\n        } catch (e) {\n          console.error(e.stack);\n          throw e;\n        }\n      };\n\n      if (false === cmp.execEffect(true === vflg ? 0 : 1, scb)) {\n        /* it doesn\'t execute effect */\n        scb();\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  render: function render(cmp, ef, ep) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n      /* execute layout modules */\n\n\n      cmputl.initmconf(cmp, cmputl.IDX_LAYOUT);\n      /* execute theme */\n\n      cmputl.exectheme(cmp, {});\n      /* before push event */\n\n      cmp.beforeRender();\n      /* render */\n\n      var rdom = cmp.rootDom();\n\n      for (var ridx in rdom) {\n        if (null === rdom[ridx].parent()) {\n          rdom[ridx].push({\n            target: document.body\n          });\n        } else {\n          var cmp_idx = cmp.parent().getTree().getIndex(cmp);\n          var pc_len = cmp.parent().child().length;\n\n          if (1 === pc_len || cmp_idx === pc_len - 1) {\n            /* insert to last of parent */\n            rdom[ridx].push({\n              target: rdom[ridx].parent().getRawDom()\n            });\n          } else {\n            /* insert to target index of parent */\n            rdom[ridx].push({\n              target: cmp.parent().child()[cmp_idx].rootDom()[0].getRawDom(),\n              position: \'beforebegin\'\n            });\n          }\n        }\n      }\n      /* after push event */\n\n\n      cmp.afterRender();\n      /* execute effect modules */\n\n      if ("function" === typeof ef) {\n        var ini_lst = mofron.util.effect.initlist(cmp);\n\n        if (0 === ini_lst.length) {\n          ef(cmp, cmp.visible(), ep);\n        } else {\n          var exe_ef = function exe_ef() {\n            var fin_cnt = 0;\n            return function (p1, p2, p3) {\n              try {\n                fin_cnt++;\n\n                if (p3 <= fin_cnt) {\n                  ef(cmp, cmp.visible(), ep);\n                }\n              } catch (e) {\n                console.error(e.stack);\n                throw e;\n              }\n            };\n          };\n\n          var set_exe_ef = exe_ef();\n\n          for (var iidx in ini_lst) {\n            ini_lst[iidx].otCallback(set_exe_ef, ini_lst.length);\n          }\n        }\n      }\n\n      cmputl.initmconf(cmp, cmputl.IDX_EFFECT);\n      /* execute event modules */\n\n      cmputl.initmconf(cmp, cmputl.IDX_EVENT);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  rstyle: function rstyle(cmp, sty, opt) {\n    try {\n      if (false === comutl.iscmp(cmp)) {\n        throw new Error("invalid parameter");\n      }\n\n      var root = cmp.rootDom();\n\n      for (var ridx in root) {\n        root[ridx].style(sty, opt);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nvar cmputl = mofron.util.component;\nmodule.exports = mofron.util.component;\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/component.js?')},"./node_modules/mofron/src/util/effect.js":
/*!************************************************!*\
  !*** ./node_modules/mofron/src/util/effect.js ***!
  \************************************************/
/*! no static exports found */function(module,exports){eval("/**\n * @file effect.js\n */\nvar cmputl = mofron.util.component;\nmofron.util.effect = {\n  exec: function exec(eff, eid, evf, oid) {\n    try {\n      var _oid = undefined === oid ? 0 : oid;\n\n      var elst = effutl.getlist(eff, eid, _oid);\n\n      if (0 === _oid && 0 < elst.length) {\n        effutl.transition(elst[0], true);\n      }\n\n      var next_order = function next_order() {\n        var fin_cnt = 0;\n        return function (p1, p2, p3) {\n          try {\n            fin_cnt++;\n\n            if (p3 <= fin_cnt) {\n              if (false === effutl.exec(eff, eid, evf, oid + 1)) {\n                effutl.transition(eff[0], false);\n\n                if (\"function\" === typeof evf[0]) {\n                  evf[0](p2, eid, evf[1]);\n                }\n              }\n            }\n          } catch (e) {\n            console.error(e.stack);\n            throw e;\n          }\n        };\n      };\n\n      var next = next_order(eff, eid, evf, oid);\n\n      for (var eidx in elst) {\n        elst[eidx].otCallback(next, elst.length);\n        elst[eidx].execute();\n      }\n\n      return 0 === elst.length ? false : true;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getlist: function getlist(eff, eid, oid, uflg) {\n    try {\n      var elst = [];\n\n      for (var eidx in eff) {\n        if (true === eff[eidx].isSkipped(eid, oid)) {\n          continue;\n        }\n\n        elst.push(eff[eidx]);\n      }\n\n      if (false !== uflg) {\n        /* unification effect speed */\n        var spd = 0 < elst.length ? elst[0].speed() : 0;\n        var upd = false;\n\n        for (var eidx1 in elst) {\n          if (spd < elst[eidx1].speed()) {\n            spd = elst[eidx1].speed();\n            upd = true;\n          }\n        }\n\n        if (true === upd) {\n          for (var eidx2 in elst) {\n            elst[eidx2].speed(spd);\n          }\n        }\n      }\n\n      return elst;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  initlist: function initlist(cmp) {\n    try {\n      var ret = [];\n      var chd = cmp.child();\n\n      for (var cidx in chd) {\n        var chd_ret = effutl.initlist(chd[cidx]);\n\n        if (null !== chd_ret) {\n          for (var _cidx in chd_ret) {\n            ret.push(chd_ret[_cidx]);\n          }\n        }\n      }\n\n      var eff = cmputl.modconf(cmp, cmputl.IDX_EFFECT);\n      var oid = 0;\n      var buf = null;\n\n      while (true) {\n        buf = effutl.getlist(eff, true === cmp.visible() ? 0 : 1, oid, false);\n\n        if (0 === buf.length) {\n          break;\n        }\n\n        for (var bidx in buf) {\n          ret.push(buf[bidx]);\n        }\n\n        oid++;\n      }\n\n      return ret;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  transition: function transition(eff, flg) {\n    try {\n      var spd = eff.speed();\n      var rdom = eff.component().rootDom();\n      var set = {\n        'transition': false === flg || 0 === spd ? null : 'all ' + spd + 'ms ease 0s'\n      };\n\n      for (var ridx in rdom) {\n        rdom[ridx].style(set, {\n          bpref: true\n        });\n      }\n\n      eff.component().styleDom().style(set, {\n        bpref: true\n      });\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getfirst: function getfirst(eff, eid, ord) {\n    try {\n      for (var eidx in eff) {\n        if (false === eff[eidx].isSkipped(eid, ord)) {\n          return parseInt(eidx);\n        }\n      }\n\n      return null;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  getlast: function getlast(eff, eid, ord) {\n    try {\n      var tgt_lst = [];\n\n      for (var eidx in eff) {\n        if (eid !== eff[eidx].eid()) {\n          continue;\n        } else if ('number' === typeof ord && ord !== eff[eidx].order()) {\n          continue;\n        }\n\n        tgt_lst.push(eff[eidx]);\n      }\n\n      if (0 === tgt_lst.length) {\n        return null;\n      }\n\n      var last = tgt_lst[tgt_lst.length - 1];\n\n      for (var eidx2 in eff) {\n        if (eff[eidx2].id() === last.id()) {\n          return parseInt(eidx2);\n        }\n      }\n\n      return null;\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  },\n  setconf: function setconf(cmp, einf, cnf) {\n    try {\n      var eff = cmp.effect(einf);\n\n      if (null === eff) {\n        throw new Error(\"invalid parameter\");\n      }\n\n      eff = true !== Array.isArray(eff) ? [eff] : eff;\n\n      for (var eidx in eff) {\n        eff[eidx].config(cnf);\n      }\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  }\n};\nvar effutl = mofron.util.effect;\nmodule.exports = mofron.util.effect;\n/* end of file */\n\n//# sourceURL=webpack:///./node_modules/mofron/src/util/effect.js?")},"./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nvar g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function("return this")();\n} catch (e) {\n  // This works if the window reference is available\n  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},"./src/js/init/index.js":
/*!******************************!*\
  !*** ./src/js/init/index.js ***!
  \******************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* require */\n__webpack_require__(/*! expose-loader?app!../conf/namesp.js */ "./node_modules/expose-loader/index.js?app!./src/js/conf/namesp.js-exposed");\n\n__webpack_require__(/*! mofron */ "./node_modules/mofron/index.js");\n\nvar AppBase = __webpack_require__(/*! mofron-comp-appbase */ "./node_modules/mofron-comp-appbase/index.js");\n\nvar Text = __webpack_require__(/*! mofron-comp-text */ "./node_modules/mofron-comp-text/index.js");\n\nvar HrzPos = __webpack_require__(/*! mofron-effect-hrzpos */ "./node_modules/mofron-effect-hrzpos/index.js");\n\nvar Click = __webpack_require__(/*! mofron-event-click */ "./node_modules/mofron-event-click/index.js");\n\nvar SlideMenu = __webpack_require__(/*! mofron-comp-slidemenu */ "./node_modules/mofron-comp-slidemenu/index.js");\n\nvar TxtFrame = __webpack_require__(/*! mofron-comp-txtframe */ "./node_modules/mofron-comp-txtframe/index.js");\n\nvar Frame = __webpack_require__(/*! mofron-comp-frame */ "./node_modules/mofron-comp-frame/index.js");\n\nvar Image = __webpack_require__(/*! mofron-comp-image */ "./node_modules/mofron-comp-image/index.js");\n\nvar SynwWid = __webpack_require__(/*! mofron-effect-synwwid */ "./node_modules/mofron-effect-synwwid/index.js");\n\nvar VrtPos = __webpack_require__(/*! mofron-effect-vrtpos */ "./node_modules/mofron-effect-vrtpos/index.js");\n\nvar Grid = __webpack_require__(/*! mofron-layout-grid */ "./node_modules/mofron-layout-grid/index.js");\n\nvar Circle = __webpack_require__(/*! mofron-comp-circle */ "./node_modules/mofron-comp-circle/index.js");\n\nvar Color = __webpack_require__(/*! mofron-effect-color */ "./node_modules/mofron-effect-color/index.js");\n\nvar comutl = mofron.util.common;\nvar cmputl = mofron.util.component;\n\ntry {\n  /* access */\n  if (true === mofron.util.common.chkacc({\n    device: \'mobile\'\n  })) {\n    if (true === mofron.window.isPortrait()) {\n      document.documentElement.setAttribute(\'style\', \'font-size:1500%;\');\n    }\n\n    mofron.window.portraitEvent(function () {\n      document.documentElement.setAttribute(\'style\', \'font-size:1500%;\');\n    });\n  }\n\n  if (true === mofron.util.common.chkacc({\n    device: \'mobile\'\n  })) {\n    if (true === mofron.window.isLandscape()) {\n      document.documentElement.setAttribute(\'style\', \'font-size:800%;\');\n    }\n\n    mofron.window.landscapeEvent(function () {\n      document.documentElement.setAttribute(\'style\', \'font-size:800%;\');\n    });\n  }\n\n  if (true === mofron.util.common.chkacc({\n    device: \'tablet\'\n  })) {\n    document.documentElement.setAttribute(\'style\', \'font-size:800%;\');\n  }\n\n  if (true === mofron.util.common.chkacc({\n    device: \'display\'\n  })) {\n    document.documentElement.setAttribute(\'style\', \'font-size:625%;\');\n  }\n  /* script (external) */\n\n\n  var moni = {\n    start: function start() {\n      //if (null === wsock) {\n      //    wsock = new WebSocket(\'ws:/\'+ location.host +\':5000\');\n      //    wsock.addEventListener(\'open\', (e) => {\n      //        ws_conn = true;\n      //    });\n      //    wsock.addEventListener(\'message\', msgrsv);\n      //    \n      //    setTimeout(\n      //        () => {\n      //            if (false === ws_conn) {\n      //                alert("connection error " + \'ws:/\'+ location.host +\':5000\');\n      //            }\n      //        },\n      //        1000\n      //    );\n      //}\n      sby.visible(false);\n      act.visible(true);\n    },\n    stop: function stop() {\n      //if (null !== wsock) {\n      //    wsock.close();\n      //    wsock = null;\n      //}\n      act.visible(false);\n      sby.visible(true);\n    }\n  };\n  var temp = {\n    start: function start() {\n      temp_val.text("");\n    },\n    stop: function stop() {\n      temp_val.text("-");\n    }\n  };\n  var swch = {\n    start: function start() {\n      swcir.execEffect(2);\n      dsc_txt.visible(false);\n    },\n    stop: function stop() {\n      swcir.execEffect(3);\n      dsc_txt.visible(true);\n    }\n  };\n  /* script (init) */\n\n  var Thermo = /*#__PURE__*/function () {\n    function Thermo(t) {\n      _classCallCheck(this, Thermo);\n\n      try {\n        if (!0 !== Array.isArray(t)) throw new Error("invalid parameter");\n        this.m_cmpctl = t, this.m_status = !1, this.m_wsock = null;\n      } catch (t) {\n        throw console.error(t.stack), t;\n      }\n    }\n\n    _createClass(Thermo, [{\n      key: "status",\n      value: function status() {\n        return this.m_status;\n      }\n    }, {\n      key: "switching",\n      value: function switching(t) {\n        try {\n          if ("boolean" != typeof t) throw new Error("invalid parameter");\n          !0 === t ? this.ws_connect() : null !== this.m_wsock && (this.m_wsock.close(), this.m_wsock = null);\n\n          for (var s in this.m_cmpctl) {\n            !0 === t ? this.m_cmpctl[s].start() : this.m_cmpctl[s].stop();\n          }\n\n          this.m_status = t;\n        } catch (t) {\n          throw console.error(t.stack), t;\n        }\n      }\n    }, {\n      key: "ws_connect",\n      value: function ws_connect() {\n        try {\n          this.m_wsock = new WebSocket("ws:/" + location.host + ":5000");\n          var t = !1;\n          this.m_wsock.addEventListener("open", function (s) {\n            t = !0;\n          }), setTimeout(function () {\n            !1 === t && alert("connection failed: ws:/" + location.host + ":5000");\n          }, 1e3), this.m_wsock.addEventListener("message", this.ws_message);\n        } catch (t) {\n          throw console.error(t.stack), t;\n        }\n      }\n    }, {\n      key: "ws_message",\n      value: function ws_message(t) {\n        try {\n          var s = JSON.parse(t.data);\n          act.base64("data:image/bmp;base64," + s.image), temp_val.text(s.temp + "");\n        } catch (t) {\n          throw console.error(t.stack), t;\n        }\n      }\n    }]);\n\n    return Thermo;\n  }();\n\n  var thermo = new Thermo([moni, temp, swch]);\n\n  var sw_evt = function sw_evt() {\n    try {\n      thermo.switching(!thermo.status());\n    } catch (e) {\n      console.error(e.stack);\n    }\n  };\n\n  var bar_evt = function bar_evt() {\n    menu_cmp.visible(true);\n  };\n\n  var mnu_cls = function mnu_cls() {\n    menu_cmp.visible(false);\n  };\n\n  var sel_evt = function sel_evt() {\n    console.log("select");\n  };\n\n  var msgrsv = function msgrsv(msg) {\n    try {\n      var srv_ret = JSON.parse(msg.data);\n      act.base64("data:image/bmp;base64," + srv_ret.image);\n    } catch (e) {\n      console.error(e.stack);\n      throw e;\n    }\n  };\n  /* template */\n\n\n  var menu_cmp_0 = new Text();\n  var menu_cmp = new SlideMenu();\n  var sby_0 = new Image();\n  var sby = new Frame();\n  var act = new Image();\n  var cmp0_0 = new mofron["class"].Component();\n  var temp_val = new Text("-");\n  var cmp0_1_0 = new mofron["class"].Component();\n  var cmp0_1_1_0 = new Text("â„ƒ");\n  var cmp0_1_1 = new mofron["class"].Component();\n  var cmp0_1 = new mofron["class"].Component();\n  var swcir_0 = new Image();\n  var swcir = new Circle();\n  var dsc_txt = new Text("Tap to Start");\n  var cmp0_2_0 = new mofron["class"].Component();\n  var cmp0_2 = new mofron["class"].Component();\n  var cmp0 = new AppBase();\n  var menu_cmp_1 = new TxtFrame();\n  var menu_cmp_2 = new TxtFrame();\n  var menu_cmp_3 = new TxtFrame();\n  var menu_cmp_4 = new TxtFrame();\n  var sby_0_0 = new HrzPos();\n  var sby_0_1 = new VrtPos();\n  var swcir_0_0 = new HrzPos();\n  var swcir_0_1 = new VrtPos();\n  var swcir_1 = new HrzPos();\n  var swcir_2 = new Color([80, 80, 250]);\n  var swcir_3 = new Color([250, 80, 80]);\n  var cmp0_3 = new Text("&equiv;");\n  cmp0.child([menu_cmp, cmp0_0, cmp0_1, cmp0_2]);\n  cmp0_2.child([swcir, cmp0_2_0]);\n  cmp0_2_0.child([dsc_txt]);\n  swcir.child([swcir_0]);\n  cmp0_1.child([cmp0_1_0, cmp0_1_1]);\n  cmp0_1_1.child([cmp0_1_1_0]);\n  cmp0_1_0.child([temp_val]);\n  cmp0_0.child([sby, act]);\n  sby.child([sby_0]);\n  menu_cmp.child([menu_cmp_0]);\n  menu_cmp_0.config({\n    effect: new HrzPos(),\n    event: new Click(mnu_cls),\n    style: new mofron["class"].ConfArg({\n      \'margin-top\': \'0.3rem\',\n      \'position\': \'absolute\'\n    }, {\n      \'lock\': true\n    }),\n    text: "&times;&nbsp;CLOSE"\n  });\n  menu_cmp_1.config({\n    baseColor: [245, 255, 245],\n    text: new mofron["class"].ConfArg("Notify", {\n      size: "0.2rem"\n    })\n  });\n  menu_cmp_2.config({\n    baseColor: [245, 255, 245],\n    text: new mofron["class"].ConfArg("Threshold", {\n      size: "0.2rem"\n    })\n  });\n  menu_cmp_3.config({\n    baseColor: [245, 255, 245],\n    text: new mofron["class"].ConfArg("Log", {\n      size: "0.2rem"\n    })\n  });\n  menu_cmp_4.config({\n    baseColor: [245, 255, 245],\n    text: new mofron["class"].ConfArg("FullScreen", {\n      size: "0.2rem"\n    })\n  });\n  menu_cmp.config({\n    objkey: "menu_cmp",\n    offset: "-0.01rem",\n    position: "right",\n    baseColor: [230, 255, 230],\n    select: -1,\n    reselect: true,\n    selectEvent: sel_evt,\n    style: {\n      \'padding-top\': \'0.8rem\'\n    },\n    item: new mofron["class"].ConfArg([menu_cmp_1, menu_cmp_2, menu_cmp_3, menu_cmp_4], {\n      size: new mofron["class"].ConfArg("2rem", "0.5rem")\n    })\n  });\n  sby_0.config({\n    src: "./img/standby.png",\n    effect: [sby_0_0, sby_0_1]\n  });\n  sby.config({\n    objkey: "sby",\n    effect: new SynwWid(),\n    baseColor: [220, 220, 220]\n  });\n  act.config({\n    objkey: "act",\n    effect: new SynwWid(),\n    visible: false\n  });\n  temp_val.config({\n    objkey: "temp_val",\n    size: "1rem",\n    effect: new HrzPos("right")\n  });\n  cmp0_1_1_0.config({\n    size: "1rem",\n    style: {\n      \'margin-left\': \'0.25rem\'\n    }\n  });\n  cmp0_1.config({\n    layout: new Grid([50, 50]),\n    style: {\n      \'margin-top\': \'0.3rem\'\n    }\n  });\n  swcir_0.config({\n    size: new mofron["class"].ConfArg("0.6rem", "0.6rem"),\n    src: "./img/switch.png",\n    effect: [swcir_0_0, swcir_0_1]\n  });\n  swcir_2.config({\n    eid: 2,\n    speed: 500\n  });\n  swcir_3.config({\n    eid: 3,\n    speed: 500\n  });\n  swcir.config({\n    objkey: "swcir",\n    size: "0.8rem",\n    baseColor: [250, 80, 80],\n    event: new Click(sw_evt),\n    effect: [swcir_1, swcir_2, swcir_3]\n  });\n  dsc_txt.config({\n    objkey: "dsc_txt",\n    size: "0.3rem",\n    effect: new HrzPos()\n  });\n  cmp0_2_0.config({\n    height: new mofron["class"].ConfArg("0.5rem"),\n    width: "100%"\n  });\n  cmp0_2.config({\n    style: {\n      \'position\': \'fixed\',\n      \'bottom\': \'0.1rem\'\n    },\n    effect: new HrzPos()\n  });\n  cmp0_3.config({\n    size: "0.4rem",\n    event: new Click(bar_evt)\n  });\n  cmp0.config({\n    title: "SeekGate",\n    mainColor: [230, 255, 230],\n    theme: {\n      Text: {\n        target: null,\n        config: {\n          font: "serif"\n        }\n      }\n    },\n    header: new mofron["class"].PullConf({\n      navi: cmp0_3\n    })\n  });\n  /* script (before) */\n\n  sby.height(156 * (window.innerWidth / 208) + \'px\');\n  act.height(156 * (window.innerWidth / 208) + \'px\');\n  /* start visible */\n\n  var root_cmp = new mofron["class"].Component([cmp0]);\n  root_cmp.visible(true, function () {\n    try {\n      /* script (after) */\n    } catch (e) {\n      console.error(e.stack);\n    }\n  });\n} catch (e) {\n  console.error(e.stack);\n}\n\n//# sourceURL=webpack:///./src/js/init/index.js?')}});